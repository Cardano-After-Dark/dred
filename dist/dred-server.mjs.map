{"version":3,"file":"dred-server.mjs","sources":["../src/picocolors/picocolors.ts","../src/redis/streams/constants.js","../src/redis/streams/errors.js","../src/redis/streams/channels.js","../src/types/DredEvents.ts","../platform/server/readable-stream-node-to-web.ts","../platform/server/ReadableStream.ts","../src/client/betterJsonStream.ts","../src/client/HostConnection.ts","../src/util/asyncDelay.ts","../src/client/fetcher.ts","../src/client/ConnectionManager.ts","../src/util/StringNacl.ts","../src/types/Discovery.ts","../src/peers/NeighborhoodDiscovery.ts","../src/types/ChannelSubscriptions.ts","../src/client/DredClient.ts","../src/redis/RedisSet.ts","../src/redis/RedisHash.ts","../src/peers/StaticHostDiscovery.ts","../src/server/DredServer.ts"],"sourcesContent":["import type { Colors } from \"./types.js\"\n\n// local copy of picocolors.js\n// guards against supply chain attacks\n// original ISC license preserved:\n\n// ISC License\n\n// Copyright (c) 2021-2024 Oleksii Raspopov, Kostiantyn Denysov, Anton Verinov\n\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\n\nlet p = process || {}, argv = p.argv || [], env = p.env || {}\nlet isColorSupported =\n\t!(!!env.NO_COLOR || argv.includes(\"--no-color\")) &&\n\t(!!env.FORCE_COLOR || argv.includes(\"--color\") || \n        p.platform === \"win32\" || \n        (\n            true \n        //  && (p.stdout || {}).isTTY \n        // && env.TERM !== \"dumb\"\n        ) || \n        !!env.CI\n        )\n\nlet formatter = (open, close, replace = open) => {\n    const f = (input) => {\n\t\tlet string = \"\" + input, index = string.indexOf(close, open.length)\n\t\treturn ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close\n\t}\n    f.start = open\n    f.close = close\n    return f\n}\n\nlet replaceClose = (string, close, replace, index) => {\n\tlet result = \"\", cursor = 0\n\tdo {\n\t\tresult += string.substring(cursor, index) + replace\n\t\tcursor = index + close.length\n\t\tindex = string.indexOf(close, cursor)\n\t} while (~index)\n\treturn result + string.substring(cursor)\n}\n\nlet createColors = (enabled = isColorSupported) => {\n\tlet f = enabled ? formatter : () => String\n\treturn {\n\t\tisColorSupported: enabled,\n\t\treset: f(\"\\x1b[0m\", \"\\x1b[0m\"),\n\t\tbold: f(\"\\x1b[1m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[1m\"),\n\t\tdim: f(\"\\x1b[2m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[2m\"),\n\t\titalic: f(\"\\x1b[3m\", \"\\x1b[23m\"),\n\t\tunderline: f(\"\\x1b[4m\", \"\\x1b[24m\"),\n\t\tinverse: f(\"\\x1b[7m\", \"\\x1b[27m\"),\n\t\thidden: f(\"\\x1b[8m\", \"\\x1b[28m\"),\n\t\tstrikethrough: f(\"\\x1b[9m\", \"\\x1b[29m\"),\n\n\t\tblack: f(\"\\x1b[30m\", \"\\x1b[39m\"),\n\t\tred: f(\"\\x1b[31m\", \"\\x1b[39m\"),\n\t\tgreen: f(\"\\x1b[32m\", \"\\x1b[39m\"),\n\t\tyellow: f(\"\\x1b[33m\", \"\\x1b[39m\"),\n\t\tblue: f(\"\\x1b[34m\", \"\\x1b[39m\"),\n\t\tmagenta: f(\"\\x1b[35m\", \"\\x1b[39m\"),\n\t\tcyan: f(\"\\x1b[36m\", \"\\x1b[39m\"),\n\t\twhite: f(\"\\x1b[37m\", \"\\x1b[39m\"),\n\t\tgray: f(\"\\x1b[90m\", \"\\x1b[39m\"),\n\n\t\tbgBlack: f(\"\\x1b[40m\", \"\\x1b[49m\"),\n\t\tbgRed: f(\"\\x1b[41m\", \"\\x1b[49m\"),\n\t\tbgGreen: f(\"\\x1b[42m\", \"\\x1b[49m\"),\n\t\tbgYellow: f(\"\\x1b[43m\", \"\\x1b[49m\"),\n\t\tbgBlue: f(\"\\x1b[44m\", \"\\x1b[49m\"),\n\t\tbgMagenta: f(\"\\x1b[45m\", \"\\x1b[49m\"),\n\t\tbgCyan: f(\"\\x1b[46m\", \"\\x1b[49m\"),\n\t\tbgWhite: f(\"\\x1b[47m\", \"\\x1b[49m\"),\n\n\t\tblackBright: f(\"\\x1b[90m\", \"\\x1b[39m\"),\n\t\tredBright: f(\"\\x1b[91m\", \"\\x1b[39m\"),\n\t\tgreenBright: f(\"\\x1b[92m\", \"\\x1b[39m\"),\n\t\tyellowBright: f(\"\\x1b[93m\", \"\\x1b[39m\"),\n\t\tblueBright: f(\"\\x1b[94m\", \"\\x1b[39m\"),\n\t\tmagentaBright: f(\"\\x1b[95m\", \"\\x1b[39m\"),\n\t\tcyanBright: f(\"\\x1b[96m\", \"\\x1b[39m\"),\n\t\twhiteBright: f(\"\\x1b[97m\", \"\\x1b[39m\"),\n\n\t\tbgBlackBright: f(\"\\x1b[100m\", \"\\x1b[49m\"),\n\t\tbgRedBright: f(\"\\x1b[101m\", \"\\x1b[49m\"),\n\t\tbgGreenBright: f(\"\\x1b[102m\", \"\\x1b[49m\"),\n\t\tbgYellowBright: f(\"\\x1b[103m\", \"\\x1b[49m\"),\n\t\tbgBlueBright: f(\"\\x1b[104m\", \"\\x1b[49m\"),\n\t\tbgMagentaBright: f(\"\\x1b[105m\", \"\\x1b[49m\"),\n\t\tbgCyanBright: f(\"\\x1b[106m\", \"\\x1b[49m\"),\n\t\tbgWhiteBright: f(\"\\x1b[107m\", \"\\x1b[49m\"),\n\t} as any\n}\n\nexport const colors : Colors = createColors()\n\n\n","// ============================================================================|\n/*\n* Project : HEARIT\n*\n* Developing an innovative connected/smart home intelligent\n* management system for the needs of blind or visually impaired\n* persons.\n*\n* The project has received funding from the European Regional\n* Development Fund through the Operational Program\n* \"Innovation and Competitiveness\"\n*\n* Purpose:\n* Defines all used constants in the package.\n*\n* Author: hearit.io\n*\n* License:\n*\n* MIT License\n*\n*/\n// ============================================================================|\n'use strict'\n\n// ----------------------------------------------------------------------------|\n// Common definitions\n// ----------------------------------------------------------------------------|\n\n// Separators used to compose Redis keys and indexes.\nexport const sep = {\n  HASH: '#',\n  STREAM: '|',\n  INDEX: ':',\n  OPEN: '[',\n  CLOSE: ']',\n  BIND: '-'\n}\nObject.freeze(sep)\n\n// ----------------------------------------------------------------------------|\n// The application is prepared for using a Redis cluster, it uses a fixed\n// pre-sharded approach.\n//\n// All the stream keys are fix sharded by including a hash tags in\n// the key. We split the hash slots (16384) in 32 or 64 shards in order to\n// implement load balancing in a cluster environment.\n//\n// The stream keys are going to be dynamically evenly distributed\n// during creation time. A look-up hash and sorted set will be used to\n// update the mapping.\n// ----------------------------------------------------------------------------|\n\nexport const shards32 = [\n  '{10}', '{113}', '{21}', '{3}',\n  '{61}', '{72}', '{50}', '{43}',\n  '{11}', '{112}', '{20}', '{2}',\n  '{60}', '{73}', '{51}', '{42}',\n  '{12}', '{111}', '{23}', '{1}',\n  '{63}', '{70}', '{52}', '{41}',\n  '{13}', '{110}', '{22}', '{0}',\n  '{62}', '{71}', '{53}', '{40}'\n]\n\nexport const shards64 = [\n  '{10}', '{18}', '{113}', '{342}', '{29}', '{21}',\n  '{3}', '{122}', '{69}', '{61}', '{72}', '{162}',\n  '{50}', '{58}', '{153}', '{43}', '{11}', '{19}',\n  '{112}', '{343}', '{28}', '{20}', '{2}', '{123}',\n  '{68}', '{60}', '{73}', '{163}', '{51}', '{59}',\n  '{152}', '{42}', '{12}', '{102}', '{111}', '{119}',\n  '{133}', '{23}', '{1}', '{9}', '{173}', '{63}',\n  '{70}', '{78}', '{52}', '{142}', '{49}', '{41}',\n  '{13}', '{103}', '{110}', '{118}', '{132}', '{22}',\n  '{0}', '{8}', '{172}', '{62}', '{71}', '{79}',\n  '{53}', '{143}', '{48}', '{40}'\n]\n\nexport const shards = {\n  32: shards32,\n  64: shards64\n}\nObject.freeze(shards)\n\nexport const origin = {\n  CONTEXT: 'context',\n  CONTENT: 'content'\n}\nObject.freeze(origin)\n\nexport const context = {\n  UNSUBSCRIBE: 'unsubscribe',\n  ORIGIN: 'origin'\n}\nObject.freeze(context)\n\n// ----------------------------------------------------------------------------|\n// Channel definitions\n// ----------------------------------------------------------------------------|\n// Property names used in the option properites.\n//\nexport const opt = {\n  // Channels options\n  CHANNELS: 'channels',\n  LOG: 'log',\n  OVERFLOW: 'overflow',\n  SCHEMA: 'schema',\n  SLOTS: 'slots',\n  VESRION: 'version',\n  APPLICATION: 'application',\n  SHARDED: 'sharded',\n  // Redis options\n  REDIS: 'redis',\n  NODES: 'nodes',\n  URL: 'url'\n}\nObject.freeze(opt)\n\nexport const tun = {\n  TEAM: 'team',\n  CONNECTION: 'connection',\n  CONSUMER: 'consumer',\n  KEY: 'key'\n}\nObject.freeze(tun)\n\nexport const msg = {\n  ID: 'id',\n  DATA: 'data'\n}\nObject.freeze(msg)\n\n// ----------------------------------------------------------------------------|\n// Key parts used in the pre-sharded mapping (hash and sorted sets).\nexport const pre = {\n  KEYS: 'keys',\n  SHARDS: 'shards'\n}\nObject.freeze(pre)\n\n//\n// The maximum number of elements in a stream before overflow (overwrite).\n//\nexport const overflowStreamElemNumber = 100\n\n//\n// Consumer block time out in milliseconds (used in XREADGROUP).\n//\nexport const blockStreamConsumerTimeOutMs = 10000\n\n//\n// The maximum number of elements to consume in one run (used in XREADGROUP).\n//\nexport const maxMessageStreamConsumePerRun = 100\n\n//\n// Defaults\n//\nexport const defaultAppName = 'app'\n\nexport const defaultVersion = 1\n\nexport const defaultSlotsNumb = 32\n\nexport const defaultSchema = 'channels'\n\nexport const defaultOriginType = 'all'\n\n","// ============================================================================|\n/*\n* Project : HEARIT\n*\n* Developing an innovative connected/smart home intelligent\n* management system for the needs of blind or visually impaired\n* persons.\n*\n* The project has received funding from the European Regional\n* Development Fund through the Operational Program\n* \"Innovation and Competitiveness\"\n*\n* Purpose: Defines the package errors.\n*\n* Author: hearit.io\n*\n* License:\n*\n* MIT License\n*\n*/\n// ============================================================================|\n'use strict'\n\nexport class RedisChannelsError extends Error {\n  constructor (message, error = null) {\n    super(message)\n    this.error = error\n    Error.captureStackTrace(this, RedisChannelsError)\n  }\n}\n\n","// ============================================================================|\n/*\n * Project : HEARIT\n *\n * Developing an innovative connected/smart home intelligent\n * management system for the needs of blind or visually impaired\n * persons.\n *\n * The project has received funding from the European Regional\n * Development Fund through the Operational Program\n * \"Innovation and Competitiveness\"\n *\n * Purpose:\n *\n * Pre-sharded channels implementation based on Redis streams.\n *\n * Author: hearit.io\n *\n * API:\n *\n * use, susbscribe, unsubscribe, produce, consume, delete and cleanup\n *\n * License:\n *\n * MIT License\n *\n */\n// ============================================================================|\n\"use strict\";\n\n//!!! todo: update ioredis dependency to a more recent version\n\nimport { v4 as uuidv4 } from 'uuid';\nimport Redis from \"ioredis\";\nimport * as abstractLoggingInterface from \"abstract-logging\";\n\nimport {\n    opt,\n    sep,\n    pre,\n    tun,\n    msg,\n    origin,\n    shards,\n    context,\n    overflowStreamElemNumber,\n    blockStreamConsumerTimeOutMs,\n    maxMessageStreamConsumePerRun,\n    defaultSchema,\n    defaultAppName,\n    defaultVersion,\n    defaultSlotsNumb,\n    defaultOriginType,\n} from \"./constants.js\";\n\nimport  { RedisChannelsError }  from \"./errors\";\n\nfunction redisFieldsToHash(a) {\n    //! converts a flat list of keys into a hash of the keys & primitive values.\n    const result = {};\n    for (let i = 0; i < a.length; i += 2) {\n        result[a[i]] = a[i + 1];\n    }\n    return result;\n}\nfunction hashToRedisFields(h) {\n    // converts a hash into a flat list of keys and primitive values\n    const r = [];\n    for (const [k, v] of Object.entries(h)) {\n        r.push(k, v);\n    }\n    return r;\n}\n\n/*\n * Usage example:\n *\n * const {RedisChannels} = require('@hearit-io/redis-channel')\n * const channels = new RedisChannels()\n * const tunnel = await channels.use('group')\n * await channels.subscribe(tunnel)\n *\n * async function process(tunnel) {\n *   for await (const messages of channels.consume(tunnel)) {\n *     for (const i in messages) {\n *       console.log(messages[i]);\n *     }\n *   }\n * }\n *\n * process(tunnel).catch((error) => {\n *   console.error(error);\n * });\n *\n * await channels.produce(tunnel, 'message')\n * await channels.unsubscribe(tunnel)\n *\n * await channels.delete('group')\n * await channels.cleanup()\n */\n// ----------------------------------------------------------------------------|\nexport class RedisChannels {\n    constructor(options = {}) {\n        let { channels, redis } = options;\n        channels = channels || {};\n\n        this._nonBlockRedisClient = this._createRedisClient(redis);\n\n        this._consumers = {};\n\n        this._workInTeam = false;\n        this._consumerIsGennerated = true;\n\n        if (typeof channels[opt.LOG] === \"undefined\") {\n            this._log = { ...abstractLoggingInterface }\n        } else {\n            this._log = channels[opt.LOG];\n        }\n\n        if (\n            typeof channels[opt.OVERFLOW] === \"undefined\" ||\n            Number.isInteger(channels[opt.OVERFLOW]) === false\n        ) {\n            this._overflow = overflowStreamElemNumber;\n        } else {\n            this._overflow = channels[opt.OVERFLOW];\n        }\n\n        if (typeof channels[opt.SLOTS] === \"undefined\") {\n            this._slots = defaultSlotsNumb;\n        } else {\n            if (channels[opt.SLOTS] !== 32 && channels[opt.SLOTS] !== 64) {\n                throw new RedisChannelsError(\n                    \"Invalid shards: \" +\n                        channels[opt.SLOTS] +\n                        \"allowed values are 32 or 64.\"\n                );\n            }\n            this._slots = channels[opt.SLOTS];\n        }\n\n        if (typeof channels[opt.SHARDED] === \"undefined\") {\n            this._sharded = false;\n        } else {\n            this._sharded = channels[opt.SHARDED];\n        }\n\n        let schema = defaultSchema;\n        if (typeof channels[opt.SCHEMA] !== \"undefined\") {\n            schema = channels[opt.SCHEMA];\n        }\n\n        let version = defaultVersion;\n        if (typeof channels[opt.VESRION] !== \"undefined\") {\n            version = channels[opt.VESRION];\n        }\n\n        let application = defaultAppName;\n        if (typeof channels[opt.APPLICATION] !== \"undefined\") {\n            application = channels[opt.APPLICATION];\n        }\n\n        this._prefix = application + sep.BIND + schema + sep.BIND + version;\n\n        if (this._sharded) {\n            this._keyHash =\n                this._prefix +\n                sep.HASH +\n                pre.KEYS +\n                shards[this._slots][0] +\n                sep.OPEN +\n                0 +\n                sep.CLOSE;\n\n            this._keyZset =\n                this._prefix +\n                sep.INDEX +\n                pre.SHARDS +\n                shards[this._slots][0] +\n                sep.OPEN +\n                0 +\n                sep.CLOSE;\n        }\n    }\n\n    /*\n     * Returns a tunnel object to access the channel for a particular group.\n     *\n     * It creates all related data in the Redis DB initially if necessary.\n     *\n     * Parameters:\n     *\n     * group - a string with the group id\n     *\n     * Returns a tunnel object with a builded stream 'key'.\n     *\n     * {key: <prefix>{<hash_slot>}<group>[<shard_id>]}\n     *\n     * On error throws an exception.\n     *\n     */\n    // --------------------------------------------------------------------------|\n    async use(group) {\n        try {\n            if (this._sharded === false) {\n                return {\n                    [tun.KEY]: this._prefix + sep.STREAM + group,\n                };\n            }\n\n            let keyStream = await this._nonBlockRedisClient.hget([\n                this._keyHash,\n                group,\n            ]);\n\n            // We have already the mapping group to sharded stream key.\n            if (keyStream !== null) {\n                return {\n                    [tun.KEY]: keyStream,\n                };\n            }\n\n            // We need to check the shards score.\n            let shard = await this._nonBlockRedisClient.zrangebyscore([\n                this._keyZset,\n                \"-inf\",\n                \"+inf\",\n                \"WITHSCORES\",\n                \"LIMIT\",\n                \"0\",\n                \"1\",\n            ]);\n\n            // We must initialize the shards.\n            if (shard.length === 0) {\n                await this._initShardScores();\n                shard = await this._nonBlockRedisClient.zrangebyscore([\n                    this._keyZset,\n                    \"-inf\",\n                    \"+inf\",\n                    \"WITHSCORES\",\n                    \"LIMIT\",\n                    \"0\",\n                    \"1\",\n                ]);\n            }\n\n            const [set] = shard;\n            keyStream =\n                this._prefix +\n                sep.STREAM +\n                shards[this._slots][set] +\n                group +\n                sep.OPEN +\n                set +\n                sep.CLOSE;\n\n            await this._nonBlockRedisClient.hset([\n                this._keyHash,\n                group,\n                keyStream,\n            ]);\n\n            await this._nonBlockRedisClient.zincrby([this._keyZset, 1, set]);\n\n            return {[tun.KEY]: keyStream };\n        } catch (error) {\n            this._log.error(\"Use error: %o\", error);\n            throw new RedisChannelsError(\n                \"Can not call use for a group : \" +\n                    group +\n                    \" with sharded mode = \" +\n                    this._sharded,\n                error\n            );\n        }\n    }\n\n    /*\n     * Deletes a group and all related data in a Redis DB.\n     *\n     * On error throws an exception.\n     */\n    // --------------------------------------------------------------------------|\n    async delete(group) {\n        try {\n            let keyStream = this._prefix + sep.STREAM + group;\n            if (this._sharded === false) {\n                // Unsubscribe all related consumers\n                for (const i in this._consumers) {\n                    if (this._consumers[i][tun.KEY] === keyStream) {\n                        await this.unsubscribe(this._consumers[i]);\n                    }\n                }\n                await this._nonBlockRedisClient.del([\n                    this._prefix + sep.STREAM + group,\n                ]);\n                return;\n            }\n\n            keyStream = await this._nonBlockRedisClient.hget([\n                this._keyHash,\n                group,\n            ]);\n\n            // Unsubscribe all related consumers\n            for (const i in this._consumers) {\n                if (this._consumers[i][tun.KEY] === keyStream) {\n                    await this.unsubscribe(this._consumers[i]);\n                }\n            }\n\n            const slot = keyStream.match(/\\[([0-9]+)\\]$/)[1];\n            await this._nonBlockRedisClient.del([keyStream]);\n            await this._nonBlockRedisClient.hdel([this._keyHash, group]);\n            await this._nonBlockRedisClient.zincrby([this._keyZset, -1, slot]);\n        } catch (error) {\n            this._log.error(\"Delete error: %o\", error);\n            throw new RedisChannelsError(\n                \"Can not delete  a group : \" +\n                    group +\n                    \" with sharded mode = \" +\n                    this._sharded,\n                error\n            );\n        }\n    }\n\n    /*\n     * Subscribes for a tunnel\n     *\n     * It creates a Redis clinet (for a blocking connection), a consumer,\n     * a consumer group and a stream to access the tunnel.\n     *\n     * Paramters:\n     *\n     * tunnel - a tunnel object to use.\n     *\n     * team - a name (string) of the consumer group. If not specified, every\n     *        consumer consumer will be its own unique team\n     *\n     * consumer - a unique consumer name (string) within a team . If not specified\n     *            a UUID version 4 will be generated.\n     *\n     * A subscription is necessary only for a consumer, not for a producer.\n     *\n     * On error throws an exception.\n     */\n    // --------------------------------------------------------------------------|\n    async subscribe(tunnel, team, consumer) {\n        try {\n            if (\n                typeof tunnel === \"undefined\" ||\n                typeof tunnel[tun.KEY] === \"undefined\"\n            ) {\n                throw new RedisChannelsError(\n                    \"Can not subscribe, no valid tunnel object\"\n                );\n            }\n            if (typeof consumer === \"undefined\") {\n                tunnel[tun.CONSUMER] = uuidv4().replace(/-/g, \"\");\n                this._consumerIsGennerated = true;\n            } else {\n                tunnel[tun.CONSUMER] = consumer;\n                this._consumerIsGennerated = false;\n            }\n            if (typeof team === \"undefined\") {\n                tunnel[tun.TEAM] = tunnel[tun.CONSUMER];\n                this._workInTeam = false;\n            } else {\n                tunnel[tun.TEAM] = team;\n                this._workInTeam = true;\n            }\n\n            // Tries to create a consumer group and a stream if not exists.\n            try {\n                // We need to create a stream even we do not need a group.\n                await this._nonBlockRedisClient.xgroup([\n                    \"CREATE\",\n                    tunnel[tun.KEY],\n                    tunnel[tun.TEAM],\n                    \"$\",\n                    \"MKSTREAM\",\n                ]);\n                await this._deleteRedisConsumerAndGroup(tunnel);\n            } catch {}\n\n            // Creates a redis client if necessery.\n            if (!(tunnel[tun.CONSUMER] in this._consumers)) {\n                tunnel[tun.CONNECTION] = this._duplicateRedisClient();\n                this._consumers[tunnel[tun.CONSUMER]] = tunnel;\n            }\n        } catch (error) {\n            this._log.error(\"Subscribe error: %o\", error);\n            throw error;\n        }\n    }\n\n    /*\n     * Unsubscribes a tunnel.\n     *\n     * On error throws an exception.\n     */\n    // --------------------------------------------------------------------------|\n    async unsubscribe(tunnel) {\n        try {\n            if (\n                typeof tunnel === \"undefined\" ||\n                typeof tunnel[tun.TEAM] === \"undefined\" ||\n                typeof tunnel[tun.CONSUMER] === \"undefined\"\n            ) {\n                throw new RedisChannelsError(\n                    \"Can not unsubscribe, no valid tunnel object\"\n                );\n            }\n            // !!! probably we do not need to issue a message into the\n            // channel saying that a team/consumer is unsubscribing...\n\n            const { [tun.TEAM]: team, [tun.CONSUMER]: consumer } = tunnel;\n\n            const fields = {\n                _action: \"unsubscribe\",\n                _team: team,\n                _consumer: consumer,\n            };\n            const f = hashToRedisFields(fields)\n            await this._nonBlockRedisClient.xadd([\n                tunnel[tun.KEY],\n                \"MAXLEN\",\n                \"~\",\n                this._overflow,\n                \"*\",\n                ...f\n            ]);\n        } catch (error) {\n            this._log.error(\"Unsubscribe error: %o\", error);\n            if (error instanceof RedisChannelsError) {\n                throw error;\n            }\n            throw new RedisChannelsError(\n                \"Can not unsubscribe for consumer : \" + tunnel[tun.CONSUMER],\n                error\n            );\n        }\n    }\n\n    /*\n     * Produces a message in a channel with a given tag for the type of message.\n     *\n     * Parameters:\n     *\n     * tunnel - a tunnel object (result form use)\n     *\n     * message - a string, message to produce.  Stored as a 'data'  key in the \n     *          RedisStreams message.\n     *\n     * options: an object.  its keys and values are included in the RedisStreams \n     *          message.  \n     *\n     * options.type - a string, can be used to distinguish between message sources.\n     *        Default value is 'all'.  Stored as _type in RedisStreams.\n     *\n     * Returns the id of the produced message\n     *\n     * On error throws an error\n     */\n    // --------------------------------------------------------------------------|\n    async produce(\n        tunnel,\n        message,\n        { _type = defaultOriginType, ...appFields } = {}\n    ) {\n\n        try {\n            const data = message;\n            const redisFields = hashToRedisFields({\n                _type: _type,\n                _data: data,\n                ...appFields,\n            });\n            const id = await this._nonBlockRedisClient.xadd([\n                tunnel[tun.KEY],\n                \"MAXLEN\",\n                \"~\",\n                this._overflow,\n                \"*\",\n                ...redisFields,\n            ]);\n            return id;\n        } catch (error) {\n            this._log.error(\"Produce error:\", error.stack || error.message || JSON.stringify(error));\n            debugger\n            throw new RedisChannelsError(\n                \"Can not produce in the tunnel: \" + tunnel,\n                error\n            );\n        }\n    }\n\n    /*\n     * Consumes messages for a given type from a tun.\n     *\n     * It is an asynchronous iterator, returns an array of messages.\n     * Every message is an object {id: <string>, data: <string>, ...appAttrs},\n     * where appAttrs are any additional keys and values provided in arg3 \n     * to the produce() method\n     *\n     * Parameters:\n     *\n     * tunnel - a tunnel object (result form use)\n     *\n     * type - a string, can be used to distinguish between message sources.\n     *        Default value is 'all'.\n     *\n     * count  - a maximum number of messages consumed per iteration.\n     *          Default value is 100.\n     *\n     * timeout  - a blocking timeout in milliseconds. Default value is 10000.\n     *            If a blocking timeout is 0 a consumer will block forever.\n     *\n     * fromId - start consuming messages newer then a given id. Default value\n     *          is set to '>' or '*' whether if it is consumed in a team or not.\n     *          This means staring form messages that were never\n     *          delivered to any other consumer.\n     *          The format is <time-in-milisecounds>-<sequence> or only the\n     *          miliseconds part of the id.\n     *\n     * messageOnTimeOut - a bollean flag. If set, in a case of a timeout a\n     *         message array [{id: <last-consumed-id> data: null}] will be\n     *         returned to indecate it. If there were no consumed messages\n     *         the id value will be undefined. Default value is false.\n     * -----------------------------------------------------------------------\n     * TODO!!\n     * -----------------------------------------------------------------------\n     * acknowledge - a boolean flag. If it is set to true an explicite\n     *               confirmation (call of an acknowledge method) after a\n     *               successful processing is required. If set to false\n     *               an acknowledgement is performed automatically.\n     *               The value makes seanse when consuming in a team.\n     *\n     *\n     * Important!!!\n     *\n     * If the acknowledge flag is set a call of an acknowledge method is\n     * required after a successful processing. Otherwise the number of pending\n     * messages in the Redis will grow and will ocuppy a valuable memory.\n     * -----------------------------------------------------------------------\n     *\n     * On error throws an exeption\n     *\n     * Note:\n     *\n     * The method processes messages containg controlling context (for example\n     * a command to unsubscribe and finsh with a processing).\n     *\n     * If a consumers are working in a team it is possible that one consumer\n     * gets two 'unsubscrbe' messages. After the processing of the fisrt it will\n     * just finish. In this case some other consumer in a team will not\n     * recieve his 'unsubscribe' message.\n     *\n     * In this case a consumer should produce back all 'unsubscribe' messages,\n     * which should be recieved by all outher consumers within the same team.\n     */\n    // --------------------------------------------------------------------------|\n\n    async *consume(\n        tunnel,\n        targetType = defaultOriginType,\n        count = maxMessageStreamConsumePerRun,\n        timeout = blockStreamConsumerTimeOutMs,\n        fromId = \">\",\n        messageOnTimeOut = false\n    ) {\n        try {\n            let unsubscribing = false;\n            let currentId = fromId;\n            let lastId;\n\n            if (fromId === \">\" && this._workInTeam === false) {\n                currentId = \"$\";\n            }\n\n            while (true) {\n                const result = [];\n                let data;\n\n                if (this._workInTeam === false) {\n                    data = await this._consumers[tunnel[tun.CONSUMER]][\n                        tun.CONNECTION\n                    ].xread([\n                        \"COUNT\",\n                        count,\n                        \"BLOCK\",\n                        timeout,\n                        \"STREAMS\",\n                        tunnel[tun.KEY],\n                        currentId,\n                    ]);\n                } else {\n                    data = await this._consumers[tunnel[tun.CONSUMER]][\n                        tun.CONNECTION\n                    ].xreadgroup([\n                        \"GROUP\",\n                        tunnel[tun.TEAM],\n                        tunnel[tun.CONSUMER],\n                        \"COUNT\",\n                        count,\n                        \"BLOCK\",\n                        timeout,\n                        \"NOACK\",\n                        \"STREAMS\",\n                        tunnel[tun.KEY],\n                        currentId,\n                    ]);\n                }\n                // We have a time out\n                if (data === null) {\n                    // If we are using XREAD we should check if the stream exist.\n                    // Otherwise a consumer will not finish after a delete stream\n                    // operation and a timeout.\n                    if (this._workInTeam === false) {\n                        await this._consumers[tunnel[tun.CONSUMER]][\n                            tun.CONNECTION\n                        ].xinfo([\"STREAM\", tunnel[tun.KEY]]);\n                    }\n                    if (messageOnTimeOut) {\n                        result.push({\n                            [msg.ID]: lastId,\n                            [msg.DATA]: null,\n                        });\n                        yield result;\n                    }\n                    continue;\n                }\n\n                /*\n        // Relevant for a calls with a xreadgroup\n        if (data[0][1].length === 0 && this._workInTeam) {\n          pendingEntries = false\n          currentId = '>'\n        }\n        */\n\n                for (const stream of data) {\n                    for (const [id, f] of stream[1]) {\n                        const fields = redisFieldsToHash(f);\n\n                        const {\n                            _type,\n                            _data,\n                            _team,\n                            _action,\n                            _consumer,\n                            ...appAttrs\n                        } = fields;\n\n                        const unsubscribe = (\"unsubscribe\" === _action);\n                        if (_action && !unsubscribe) throw new Error(`bad _action value in message`);\n                        if (_team && !unsubscribe) throw new Error(`_team is only valid for _action=unsubscribe messages`);\n                        if (_consumer && !unsubscribe) throw new Error(`_consumer is only valid for _action=unsubscribe messages`);\n\n                        if (this._workInTeam === false) {\n                            currentId = id;\n                        }\n                        /*\n              if (pendingEntries) {\n                currentId = id\n              }\n              */\n\n                        //!!! todo: convert to typescript\n                        // --------------------------------------------------------------------------|\n                        if (!unsubscribe && _type === targetType) {\n                            result.push({ id, data:_data, ...appAttrs });\n                            lastId = id;\n                        } else if (unsubscribe) {\n                            if (\n                                _team === tunnel.team &&\n                                _consumer === tunnel.consumer\n                            ) {\n                                // Delete a unsubscribe message with a common nonblocking\n                                // Redis client.\n                                // Multiple unsubscribe messages are possible\n                                // for the same consumer and a team!!!\n                                await this._nonBlockRedisClient.xdel(\n                                    [tunnel.key],\n                                    id\n                                );\n\n                                if (!unsubscribing) {\n                                    // Cleanup a redis consumer and a group\n                                    await this._deleteRedisConsumerAndGroup(\n                                        tunnel\n                                    );\n                                    unsubscribing = true;\n                                }\n                            } else {\n                                // Create a message with an unsubscribe context for the right\n                                // consumer (only in a team work case).\n                                if (this._workInTeam) {\n                                    await this.unsubscribe({\n                                        team: _team,\n                                        consumer: _consumer,\n                                        key: tunnel.key,\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                if (unsubscribing) {\n                    return result;\n                }\n                yield result;\n            }\n        } catch (error) {\n            this._log.error(\"Consume error: %o\", error);\n            throw new RedisChannelsError(\n                \"Can not consume from the tunnel: \" +\n                    tunnel[tun.KEY] +\n                    \" \" +\n                    tunnel[tun.CONSUMER],\n                error\n            );\n        }\n    }\n\n    // TOODO\n    /*\n     * Acknowledges a message specified with an id.\n     */\n\n    /*\n  // --------------------------------------------------------------------------|\n  async acknowledge (tunnel, id) {\n    try {\n\n      await this._nonBlockRedisClient\n        .xack([tunnel[tun.KEY], tunnel[tun.TEAM], id])\n    } catch { }\n  }\n  */\n\n    /*\n     * Closes all redis clients and deletes all consumers and consumer groups\n     */\n    // --------------------------------------------------------------------------|\n    async cleanup() {\n        for (const i in this._consumers) {\n            await this._deleteRedisConsumerAndGroup(this._consumers[i], true);\n\n            await this._consumers[i][tun.CONNECTION].quit();\n            this._consumers[i][tun.CONNECTION].removeAllListeners();\n            delete this._consumers[i];\n        }\n        await this._nonBlockRedisClient.quit();\n        this._nonBlockRedisClient.removeAllListeners();\n    }\n\n    /*\n     * Deletes a redis consumer and a group\n     */\n    // --------------------------------------------------------------------------|\n    async _deleteRedisConsumerAndGroup(tunnel, force = false) {\n        try {\n            // Deletes a consumer and a consumer group\n            if (this._workInTeam === false || force) {\n                await this._nonBlockRedisClient.xgroup([\n                    \"DELCONSUMER\",\n                    tunnel[tun.KEY],\n                    tunnel[tun.TEAM],\n                    tunnel[tun.CONSUMER],\n                ]);\n\n                // Deletes a consumer group\n                const teams = await this._nonBlockRedisClient.xinfo([\n                    \"GROUPS\",\n                    tunnel[tun.KEY],\n                ]);\n                for (const i in teams) {\n                    // We can not rely on fields exact positions - according to\n                    // https://redis.io/commands/xinfo.\n                    const k = teams[i].indexOf(\"name\");\n                    if (k < 0 || teams[i][k + 1] !== tunnel[tun.TEAM]) {\n                        continue;\n                    }\n                    const j = teams[i].indexOf(\"consumers\");\n                    if (j >= 0 && teams[i][j + 1] === 0) {\n                        await this._nonBlockRedisClient.xgroup([\n                            \"DESTROY\",\n                            tunnel[tun.KEY],\n                            tunnel[tun.TEAM],\n                        ]);\n                    }\n                    break;\n                }\n            }\n        } catch {}\n    }\n\n    /*\n     *\n     * Initialize all sorted sets which are used to distribute equable stream\n     * keys over the shards.\n     *\n     * On error throws an exeption\n     */\n    // --------------------------------------------------------------------------|\n    async _initShardScores() {\n        try {\n            for (let i = 0; i < this._slots; i++) {\n                await this._nonBlockRedisClient.zincrby([this._keyZset, 0, i]);\n            }\n        } catch (error) {\n            this._log.error(\"_initShardScores error: %o\", error);\n            throw new RedisChannelsError(\n                \"Can not initialize shards score for the channels\",\n                error\n            );\n        }\n    }\n\n    // --------------------------------------------------------------------------|\n    _createRedisClient(opts) {\n        const { nodes, url, ...options } = opts || {};\n\n        let redis;\n        if (nodes && Array.isArray(nodes)) {\n            // We have a Cluster instance\n            redis = new Redis.Cluster(nodes, options);\n        } else {\n            // We have a Redis instance\n            if (url) {\n                redis = new Redis(url, options);\n            } else {\n                redis = new Redis(options);\n            }\n        }\n\n        redis.addListener(\"error\", () => {\n            // Disable all errors.\n        });\n        return redis;\n    }\n\n    // --------------------------------------------------------------------------|\n    _duplicateRedisClient() {\n        const redis = this._nonBlockRedisClient.duplicate();\n        redis.addListener(\"error\", () => {\n            // Disable all errors.\n        });\n        return redis;\n    }\n}\n\n","import { EventEmitter } from \"eventemitter3\";\n\n// import { MarkRequired } from \"ts-essentials\";\n\n\n//! it makes these available for in-package development,\n//  but they're not really intended to be used by external developers,\n//  so we hide them behind symbols.  String keys are fair game for externals\nexport const eventMeaning = Symbol(\"?meaning?\");\nexport const devMessage = Symbol(\"?developer?\");\n// export const emitterHelp = Symbol(\"?emitter?\");\n\nexport type stringMap<T> = Record<string, T>\nexport type HelpText = stringMap<string>\nexport interface DredEvent {\n    //! it does not necessarily represent in-channel message events,\n    //   but can indicate operational events occuring before or outside the scope of a channel \n\n    //! it uses a 'message' field, so is usable for errors as well as for non-errors.\n    //   the message field should generally be useful for onscreen messaging\n    message: string;\n\n    //! it uses an optional 'recommendation' field, whose content SHOULD be used\n    //   to advise the user on a way they can proceed.  \n    recommendation?: string;\n\n    //! it uses alt-message fields containing alternative messages that may be used\n    //   in applications that have special realtime- or security-focused expectations.\n    altMessageRealtime?: string;\n    altMessageSecurity?: string;\n\n    //! it uses a development-only message, adding contextual information for\n    //  developers to use for interpretation or guidance around the event.  It is\n    //  structured as a symbol so that the information is easy to see but difficult\n    //  to re-present to end users.\n    [devMessage]: string | string[];\n\n    //! it allows additional untyped entries\n    // [key: string]: any;\n    // [emitterHelp]: Record<string, string>;\n}\n\n\n\nexport interface DredError extends DredEvent {\n    reason: string | Error\n    [key: string]: any;\n}\n\n// export type DredEventArg = Omit<DredEvent, typeof emitterHelp>\n\n// EventEmitter has type-safety conventions for emit() and on().\n//    examples:\n// type things = {\n//     thing1: (d: DredEvent<any>) => void;\n//     thing2: (d: DredEvent<any>) => void;\n// }\n// type EE = EventEmitter<things>;\n// const t : EE = new EventEmitter();\n// t.emit(\"thing3\")\n// t.on(\"thing2\", (d) => {\n//     d[devMessage]\n// })\n\nexport type DredNotificationStruct = Record<string, Function | any>;\nexport type DredEventPlus<moreFields> = {\n    [key in keyof DredEvent]: DredEvent[key];\n} & {\n    [key in keyof moreFields]: moreFields[key];\n};\n\nexport type EventHelpAllowedEvents<EH extends EmitterDef> = keyof EH[\"help\"];\nexport interface EmitterDef {\n    _info: string;\n    help: HelpText \n    handlers?: DredNotificationStruct;\n}\ntype test = [DredEvent] extends any[] ? \"yes\" : never\ntype singleRequiredEvent = [DredEvent];\n{\n    //! it only allows a single item, but still matches array 'any[]'\n    const check: singleRequiredEvent extends any[] ? \"good\" : never = \"good\";\n}\n\ntype DredNotifierFunc = (...e: singleRequiredEvent) => void;\n\n// type selfDoc = {\n//     __note: \"the default handler for Dred types receives a DredEvent object, and all you need to do is include a help string.\",\n//     __override: \"... if desired, customize the data-types for args to notifications in emit() and on(... handler(...args)), by adding your handler-type here\",\n// }\n\n//! it provides a type facade to describe available events\nexport interface hasEvents<ha extends Record<string, Function>> {\n    [key: string]: // selfDoc extends {key : string] ? selfDoc[key] :\n    ha extends { key: infer HT } ? HT : never;\n}\n","//! see ./ReadableStream.ts\n\n// !!! compare to\n//  https://raw.githubusercontent.com/xuset/readable-stream-node-to-web/master/index.js\n\nimport { ReadableStream } from \"node:stream/web\";\n\n//! converts a nodejs Readable Stream as returned by `node-fetch` and `cross-fetch`\n//  ... into a web-readable-stream \"node:stream/web\"\nexport function nodeToWebStream(nodeStream) {\n    // Assumes the nodeStream has not ended/closed\n    var destroyed = false;\n    var listeners = {};\n\n    function start(controller) {\n        listeners[\"data\"] = onData;\n        listeners[\"end\"] = onData; // wtf no-op, see next line\n        listeners[\"end\"] = onDestroy;\n        listeners[\"close\"] = onDestroy;\n        listeners[\"error\"] = onDestroy;\n        for (var name in listeners) nodeStream.on(name, listeners[name]);\n\n        nodeStream.pause();\n\n        function onData(chunk) {\n            if (destroyed) return;\n            controller.enqueue(chunk);\n            nodeStream.pause();\n        }\n\n        function onDestroy(err) {\n            if (destroyed) return;\n            destroyed = true;\n\n            for (var name in listeners)\n                nodeStream.removeListener(name, listeners[name]);\n\n            if (err) controller.error(err);\n            else controller.close();\n        }\n    }\n\n    function pull() {\n        if (destroyed) return;\n        nodeStream.resume();\n    }\n\n    function cancel() {\n        destroyed = true;\n\n        for (var name in listeners)\n            nodeStream.removeListener(name, listeners[name]);\n\n        nodeStream.push(null);\n        nodeStream.pause();\n        if (nodeStream.destroy) nodeStream.destroy();\n        else if (nodeStream.close) nodeStream.close();\n    }\n\n    return new ReadableStream({ start: start, pull: pull, cancel: cancel });\n}\n","import { ReadableStream as platformReadableStream } from \"node:stream/web\";\nimport { nodeToWebStream } from \"./readable-stream-node-to-web.js\";\nimport { Readable } from \"node:stream\";\n\n//! purpose: allows server-side code to handle fetch() responses with a streaming\n//   interface matching the browser's ReadableStream standard, so that browser- \n//   and server-side code can uniformly use that single (better) interface.\n\n// Supports older nodejs versions via node-fetch and an adapter in nodeToWebStream().\n\n// Supports newer versions via their web-api-compliant fetch() \n//   .., and native web-compliant ReadableStream, which doesn't need adapting.\n\nexport const ReadableStream = platformReadableStream\nexport default ReadableStream;\nexport function fromPlatformFetchBody(b) {\n    // Readable is the old-style nodejs readable stream.\n    if (b instanceof Readable) return nodeToWebStream(b);\n\n    // modern web stream from native fetch doesn't need conversion:\n    return b\n}\n","\"use strict\";\n\nimport { ReadableStream } from \"@platform/ReadableStream\";\n\n/*exported ndjsonStream*/\n// forked from can-ndjson-stream because its error handling is sub-par.\n\nexport function ndjsonStream(responseBody) {\n    // For cancellation\n    let is_reader,\n        cancellationRequest = false;\n    return new ReadableStream({\n        start: function (controller) {\n            var reader = responseBody.getReader();\n            is_reader = reader;\n            var decoder = new TextDecoder();\n            var data_buf = \"\";\n\n            return reader.read().then(function processResult(result) {\n                if (result.done) {\n                    if (cancellationRequest) {\n                        // Immediately exit\n                        return;\n                    }\n\n                    data_buf = data_buf.trim();\n                    if (data_buf.length !== 0) {\n                        try {\n                            var data_l = JSON.parse(data_buf);\n                            controller.enqueue(data_l);\n                        } catch (e) {\n                            console.error(\"error while parsing: \", {\n                                data_buf,\n                                e,\n                            });\n                            controller.error(e);\n                            return;\n                        }\n                    }\n                    controller.close();\n                    return;\n                }\n\n                var data = decoder.decode(result.value, { stream: true });\n                data_buf += data;\n                var lines = data_buf.split(\"\\n\");\n                for (var i = 0; i < lines.length - 1; ++i) {\n                    var l = lines[i].trim();\n                    if (l.length > 0) {\n                        try {\n                            var data_line = JSON.parse(l);\n                            controller.enqueue(data_line);\n                        } catch (e) {\n                            controller.error(e);\n                            cancellationRequest = true;\n                            reader.cancel();\n                            return;\n                        }\n                    }\n                }\n                data_buf = lines[lines.length - 1];\n\n                return reader.read().then(processResult);\n            });\n        },\n        cancel: function (reason) {\n            console.debug(\"Cancel registered due to \", reason);\n            cancellationRequest = true;\n            is_reader.cancel();\n        },\n    });\n}\n","import { autobind, StateMachine } from \"@poshplum/utils\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { fromPlatformFetchBody } from \"@platform/ReadableStream\";\n\nimport { connnectionSettings, DredHostDetails } from \"../types/DredHosts.js\";\n// import { asyncDelay } from \"../util/asyncDelay.js\";\nimport {\n    DredEvent,\n    // EventHelpAllowedEvents,\n    // eventHelp, DredEmitter, dredEmitter, EventInterface,\n    DredEventPlus,\n    DredError,\n    devMessage,\n} from \"../types/DredEvents.js\";\nimport { asyncDelay } from \"../util/asyncDelay.js\";\nimport { SubscriptionListenerMap, DredChannelMessage, SubscriptionList } from \"../types/ChannelSubscriptions\";\nimport { ndjsonStream } from \"./betterJsonStream.js\";\nimport { DredMessage } from \"./DredClient.js\";\n\ntype conn = HostConnection;\nexport interface ConnectionEvent extends DredEvent {\n    connection: HostConnection;\n}\nexport interface moreInfo {\n    moreInfo?: any;\n}\n\nexport interface HostConnectionEventTypes {\n    warning: [ConnectionEvent & moreInfo];\n    failed: [ConnectionEvent & DredError];\n    retrying: [ConnectionEvent];\n    connected: (\n        c: ConnectionEvent & {\n            delayTime: number;\n            attempts: number;\n        }\n    ) => void;\n    replacedBy: [ConnectionEvent & { replacement: HostConnection }];\n    message: [ConnectionEvent & DredChannelMessage & DredMessage];\n    disconnected: [ConnectionEvent & DredError];\n}\n\nconst connectionStates = {\n    logLevel: \"info\",\n    connecting: {\n        default: true,\n\n        onEntry(this: conn) {\n            this.connect().then(this.mkTransition(\"connected\"), (e: any) => {\n                this.lastError = e;\n                this.transition(\"retry\");\n            });\n        },\n        abort: \"aborted\",\n        retry: \"retrying\",\n        connected: \"connected\",\n    },\n    retrying: {\n        failed: \"failed\",\n        reconnect: {\n            nextState: \"connecting\",\n            effect(this: conn) {\n                this.connect();\n            },\n        },\n        abort: \"aborted\",\n        async onEntry(this: conn) {\n            this.attempts += 1;\n            if (this.attempts > this.settings.maxRetries) return this.transition(\"failed\");\n            this.retryLater();\n        },\n    },\n    connected: {\n        onEntry(this: conn) {\n            const now = new Date();\n            this.events.emit(\"connected\", {\n                connection: this,\n                message: \"successful connection to neighborhood host\",\n                attempts: this.attempts,\n                delayTime: this.elapsedTime(),\n                [devMessage]: [\n                    \"The connection is established and will emit 'message' events when received from the host.\",\n                ],\n            });\n        },\n        abort: \"aborted\",\n        disconnected: {\n            nextState: \"disconnected\",\n            predicate(this: conn) {\n                return !this.abortController?.signal.aborted;\n            },\n            effect(this: conn) {\n                //!!! todo: put the event trigger more directly in the spot where disconnection is detected (with any error message), plus the transition()\n                this.events.emit(\"disconnected\", {\n                    message: \"server disconnected\",\n                    connection: this,\n                    reason: \"... from new location TBD\",\n                    [devMessage]: [\n                        \"no action needed; ConnectionManager will retry\",\n                    ],\n                });\n            },\n        },\n    },\n    failed: {\n        onEntry(this: conn) {\n            this.events.emit(\n                \"failed\",\n                this.mkEvent({\n                    message: `giving up after persistent connection failure (${this.settings.maxRetries} attempts). `,\n                    recommendatIon:\n                        \"check network connection, use patience, retry.  Do you have another way to connect to the network?\",\n                    [devMessage]: [\n                        `The HostConnection object tried hard to get connected`,\n                        `The connection manager is expected to retry, so it may be`,\n                        `... better not to make maxRetries larger or to Infinity to keep retrying.`,\n                        `See also: the 'retrying' event offered by the host connection.`,\n                    ],\n                })\n            );\n        },\n    },\n    //! aborts (from 'disconnected') and disconnects (from 'aborted') don't change the terminal states.\n    disconnected: {\n        //! disconnection is terminal; should be freed and garbage collected\n        abort: \"disconnected\",\n\n        onEntry(this: conn) {\n            this.stopRetries();\n        },\n    },\n    aborted: {\n        //! an aborted connection is terminal; should be freed and garbage collected\n        disconnected: \"aborted\",\n\n        onEntry(this: conn) {\n            this.stopRetries();\n        },\n    },\n};\n\nconst connectionEvents = {\n    warning:\n        \"we timed out or encountered a problem connecting, but we'll keep retrying for a while\",\n    failed:\n        \"we stopped trying to make this connection work.  Another HostConnection \" +\n        \"to this host might be created by the connection manager, but this connection \" +\n        \"never got started and is dead, dead, dead.\",\n    connected: \"successful connection; monitoring for new events in subscribed channels.\",\n\n    message: \"message received from a subscribed channel\",\n    replacedBy: \"a new connection (see the 'replacedBy' key) replaced this one.\",\n    disconnected: \"disconnected due to network error or missed heartbeats.\",\n    aborted: \"connection aborted normally by controlling signal\",\n};\nexport class HostConnection extends StateMachine.withDefinition(\n    connectionStates,\n    \"connection-manager\"\n) {\n    static emitterHelp = connectionEvents;\n    events = new EventEmitter<HostConnectionEventTypes, any>();\n    abortController?: AbortController;\n    host: DredHostDetails;\n    settings: connnectionSettings;\n    attempts = 0;\n    lastError?: any;\n    channelSubs: SubscriptionList;\n    private stream?: ReturnType<typeof ndjsonStream>;\n\n    private startTime = new Date().getTime();\n    private scheduledRetry?: ReturnType<typeof setTimeout>;\n\n    private _status!: string; // assigned by state-machine\n    //@ts-expect-error -  base class has void as return type.  fix when state machine gets typescript love.\n    set currentState(v: string) {\n        this._status = v;\n    }\n    //@ts-expect-error -  base class has void as return type.  fix when state machine gets typescript love.\n    get currentState() {\n        return this._status;\n    }\n\n    elapsedTime(this: HostConnection): number {\n        const now = new Date();\n        return now.getTime() - this.startTime;\n    }\n\n    retryLater() {\n        const retryInterval = this.nextRetryInterval();\n        const { maxRetries } = this.settings;\n        //!!! todo: it only emits a warning if this.events.listeners indicates nobody is listening for the 'retrying' event.\n        this.events.emit(\n            \"warning\",\n            this.mkEvent({\n                message: `connection error; will retry in ${Math.floor(\n                    retryInterval / 1000\n                )} seconds`,\n                [devMessage]: \"subscribe to 'retrying' to remove this warning.\",\n                retryCount: this.attempts,\n                maxRetries,\n            })\n        );\n        this.scheduledRetry = setTimeout(this.mkTransition(\"reconnect\"), retryInterval);\n\n        this.events.emit(\n            \"retrying\",\n            this.mkEvent({\n                message: `connection error; will retry in ${Math.floor(\n                    retryInterval / 1000\n                )} seconds`,\n                [devMessage]: [\n                    \"This host connection got an error or timeout trying to connect, but it will retry on its own.\",\n                    \"Each retry will be delayed a bit longer than the previous one. \",\n                ],\n                retryCount: this.attempts,\n                maxRetries,\n            })\n        );\n    }\n\n    eventWithMessage<T>(m: string, e: T) {\n        return {\n            message: ``,\n            ...e,\n        };\n    }\n\n    nextRetryInterval(): number {\n        return Math.min(\n            this.settings.retryBaseIntervalMs * Math.pow(1.27, this.attempts),\n            this.settings.retryMaxIntervalMs\n        );\n    }\n    disconnect(reason: string) {\n        //!!! todo: cancel any pending stream with ReadableStream.cancel()\n\n        if (this.abortController) this.abortController.abort(`disconnect(): ${reason}`);\n        this.stopRetries();\n    }\n    stopRetries() {\n        if (this.scheduledRetry) clearTimeout(this.scheduledRetry);\n\n        this.scheduledRetry = undefined;\n    }\n    async replacedBy(otherConnection: HostConnection) {\n        this.events.emit(\"replacedBy\", {\n            connection: this,\n            replacement: otherConnection,\n            message: \"this connection was replaced, probably due to new subscription settings\",\n            [devMessage]: [\n                \"This is a normal operational condition when changing channel-subscription settings.\",\n                \"Connection manager is expected to move this old connection to the graveyard\",\n                \"... and get rid of any references, listeners, etc on the old connection ...\",\n                \"... to ensure it is properly garbage collected.\",\n            ],\n        });\n    }\n    connecting: Promise<any | never>;\n    static settingsWithDefaults(\n        partialSettings: Partial<connnectionSettings>\n    ): connnectionSettings {\n        return {\n            retryBaseIntervalMs: 1000,\n            retryMaxIntervalMs: 30000,\n            maxRetries: Infinity,\n            connectionWaitTimeMs: 7000,\n            ...partialSettings,\n        };\n    }\n    constructor(\n        host: DredHostDetails,\n        subscriptions: SubscriptionList,\n        settings: Partial<connnectionSettings>\n    ) {\n        super({\n            contextLabel: `connection:${host.serverId}`,\n            currentState: \"default\",\n            logFacility: \"connection:state\",\n            contextObject: null,\n        });\n        const settingsWithDefaults: connnectionSettings = {\n            retryBaseIntervalMs: 1000,\n            retryMaxIntervalMs: 30000,\n            maxRetries: Infinity,\n            connectionWaitTimeMs: 7000,\n            ...settings,\n        };\n        this.settings = HostConnection.settingsWithDefaults(settings);\n\n        this.events.on(\"replacedBy\", ({}) => {});\n        this.host = host;\n        this.channelSubs = subscriptions;\n        this.connecting = this.connect();\n    }\n\n    async connect(): Promise<any | never> {\n        this.abortController = new AbortController();\n        const { signal } = this.abortController;\n        signal.addEventListener(\"abort\", () => {\n            this.transition(\"abort\");\n        });\n        const myself = (this.connecting = new Promise((res, rej) => {\n            let aborted = false;\n            const channelSubs = {};\n            this.fetch(`/channels/listen`, {\n                body: JSON.stringify(this.channelSubs, null, 2),\n                method: \"POST\",\n                signal,\n                headers: { \"content-type\": \"application/json\" },\n            })\n                .then((response: Response) => {\n                    if (aborted) return false;\n                    if (this.abortController?.signal.aborted) return false;\n\n                    //!!! todo: check to see if we shoudl reject with an empty / non-existent response here\n                    if (!response) return false;\n\n                    res(true);\n                })\n                .catch((e) => {\n                    debugger;\n                    if (this.isAbortError(e)) {\n                        // this.log(\"abort happened before fetch response headers\");\n                        aborted = true;\n                    } else {\n                        console.warn(`fetch error; see debugger - `, e);\n                        this.events.emit(\"failed\", this.connectionFailureEvent(e));\n                        debugger;\n                    }\n                });\n        }));\n    }\n\n    mkEvent<T extends Pick<DredError, \"message\" | typeof devMessage> & Record<any, any>>(\n        args: T\n    ): ConnectionEvent & DredError {\n        const { [devMessage]: dm, message, ...moreArgs } = args;\n        return {\n            connection: this,\n            message: `[${this.host.serverId} at ${this.host.address}]: ${message}`,\n            reason: this.lastError,\n            [devMessage]: dm,\n            ...moreArgs,\n        };\n    }\n\n    connectionFailureEvent(this: HostConnection, e: Error) {\n        return {\n            connection: this,\n            reason: e,\n            message: `[${this.host.serverId} at ${this.host.address}] connection failure`,\n            recommendation: \"check for network connectivity, retry if needed\",\n            [devMessage]: [\n                \"developers should check for correctness of the fetch call\",\n                \"Connection manager is expected to monitor for failed connections ...\",\n                \"... and ensure that a suitable replacement is created.  \",\n                \"Connection manager is expected to detect persistent connection problems ...\",\n                \"... IF the OVERALL health of the neighborhood is affected,\",\n                \"... and to escalate the message/recommendation info to users\",\n                \"For more troubleshooting, check the 'reason' error object, and for deeper inspection,\",\n                \"... there is also a debugging breakpoint available\",\n            ],\n        };\n    }\n\n    //! it implements a streaming listener for changes\n    async fetch(path: string, { debug = false, ...options }) {\n        if (path[0] !== \"/\") path = `/${path}`;\n\n        const { host } = this;\n        const proto = host.insecure ? \"http\" : \"https\";\n        const shortServer = `${host.address}:${host.port}`;\n        const url = `${proto}://${shortServer}${path}`;\n        // console.warn(`+fetch`, options.method, shortServer, path)\n\n        options.mode = \"cors\";\n        //!!! todo: it includes cryptographic credentials in the connection for the server\n        //    to validate.  See also todo 61pk3h0 in server\n        // options.credentials = \"include\"; \n        const result = await fetch(url, options);\n        if (debug) debugger;\n\n        //! successful requests are directly resolved to the parsed json ...\n        //   ...unless parse:false is provided; this allows the response to be hooked up\n        //   to a streaming reader or take other treatment provided by the caller.\n        if (result.ok) {\n            this.monitorSubscriptions(result);\n            return result;\n        }\n\n        //! failed requests @request or parsing level cause a rejection.\n        // let reason : string | Error;\n        const reason = await result.json().catch((r) => {\n            return new Error(`${result.status} ${result.statusText} for ${path}`);\n        });\n\n        this.events.emit(\"failed\", this.connectionFailureEvent(reason));\n\n        return Promise.reject(reason);\n    }\n\n    async monitorSubscriptions(response: Response) {\n        if (!response.ok) throw new Error(`failure in listen...`);\n\n        const compatResponse = fromPlatformFetchBody(response.body);\n        this.stream = ndjsonStream(compatResponse);\n\n        const reader = this.stream.getReader();\n        let event: undefined | { value?: string; done: boolean },\n            connected = true;\n\n        const detectReadError = (e: Error) => {\n            if (this.isAbortError(e)) {\n                // this.log(\"abort detected while reading responses\");\n                connected = false;\n            } else {\n                console.warn(`fetch error during read; see debugger - `, e);\n                this.events.emit(\n                    \"warning\",\n                    this.mkEvent({\n                        message: \"fetch error during read\",\n                        [devMessage]: [\n                            \"probably this is caused by a network connection error\",\n                            \" ... or server-side idle timeout, though we'd hope to get a toodleoo first.\",\n                            \"Connection manager can sometimes safely ignore a couple of these,\",\n                            \" ... especially if the user has gone idle\",\n                            \" ... and/or if the app doesn't have special realtime or security requirements.  \",\n                            \" ... it SHOULD re-establish a healthy connection set when activity resumes\",\n                        ],\n                        reason: e,\n                    })\n                );\n                debugger;\n            }\n            return undefined;\n        };\n\n        while (connected) {\n            event = await reader.read().catch(detectReadError);\n            if (!event) break;\n            if (!connected) break;\n            const ts = new Date();\n            const { value, done } = event as { value: any; done: boolean };\n            if (done) {\n                this.events.emit(\n                    \"disconnected\",\n                    this.mkEvent({\n                        message: \"server disconnected\", \n                        [devMessage]:\n                            \"The server disconnected cleanly, notifying us that it was done. \",\n                    })\n                );\n                this.transition(\"disconnected\");\n                debugger;\n                return;\n            }\n            if (\"heartbeat\" == value?.type) {\n                this.heartbeatReceived();\n                continue;\n            }\n            if (\"heartbeat-info\" == value?.type) {\n                const { heartbeatInterval } = value;\n                this.heartbeatInterval = heartbeatInterval;\n                continue;\n            }        \n            if (\"warning\" == value?.type) {\n                //!!! todo: consider how & whether integrate this so that the warning becomes actionable\n                //     to ConnectionManager or beyond.  See todo c1hxed4 in ConnectionManager around that too.\n                console.log(\"warning from host\", this.host.serverId, \":\", value)\n                debugger\n                continue;\n            }\n            \n            // console.log(`client: ${chan} <- event: `, value);\n            const { mid, ocid, channel, nbh, type, msg, ...details } = value;\n            const normalMessage = \"normal message notification.  Connection manager should aggregate messages and deduplicate, while notifying clients of the new message.\"\n            const errorMessage = \"this indicates an internal problem being reflected out to you for any appropriate client-side treatment of the condition\"\n            const devInfo = \"error\" === type ? errorMessage : normalMessage\n            this.events.emit(\"message\", {\n                connection: this,\n                message: \"msg received in chan\",\n                mid,\n                ocid,\n                type,\n                msg,\n                channel,\n                details,\n                neighborhood: nbh,\n                ts,\n                [devMessage]: devInfo\n                    ,\n            });\n        }\n    }\n    isAbortError(e: any) {\n        return \"AbortError\" === e.name;\n    }\n    heartbeatInterval: number = 10000;\n    lastHeartbeat: number = new Date().getTime();\n    private heartbeatTimer?: ReturnType<typeof setTimeout>;\n    heartbeatReceived() {\n        const now = new Date().getTime();\n        this.lastHeartbeat = now;\n        if (this.heartbeatTimer) clearTimeout(this.heartbeatTimer);\n        this.heartbeatTimer = setTimeout(this.watchdog, 3 * this.heartbeatInterval);\n        this.heartbeatTimer.unref && this.heartbeatTimer.unref();\n    }\n\n    @autobind\n    watchdog() {\n        const now = new Date().getTime();\n\n        if (this.lastHeartbeat + 1.1 * this.heartbeatInterval < now) {\n            console.warn(\"Missed expected heartbeat from server\", this.host.serverId);\n        }\n\n        if (this.lastHeartbeat + 3 * this.heartbeatInterval < now) {\n            console.error(\"Missed 3 expected heartbeats from server!!!\", this.host.serverId);\n            //!!! todo: this.events.emit(\"dead\")\n        }\n    }\n}\n","export async function asyncDelay(wait: number) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, wait);\n    });\n}\n","import fetch from \"cross-fetch\";\nimport { DredHostDetails } from \"../types/DredHosts\";\n\nexport interface fetchOptions extends RequestInit {\n    host: DredHostDetails;\n    parse?: boolean;\n    debug?: boolean;\n}\n\nexport async function fetcher(path: string, options: fetchOptions) {\n    const { host, debug = false, parse = true, ...reqInit } = options;\n    if (path[0] !== \"/\") path = `/${path}`;\n\n    const proto = host.insecure ? \"http\" : \"https\";\n    const shortServer = `${host.address}:${host.port}`;\n    const url = `${proto}://${shortServer}${path}`;\n    // console.warn(`+fetch`, options.method, shortServer, path)\n\n    const result = await fetch(url, reqInit);\n    if (debug) debugger;\n\n    //! successful requests are directly resolved to the parsed json ...\n    //   ...unless parse:false is provided; this allows the response to be hooked up\n    //   to a streaming reader or take other treatment provided by the caller.\n    if (result.ok) {\n        if (!parse) return result;\n        return result.json();\n    }\n\n    //! failed requests @request or parsing level cause a rejection.\n    // let reason : string | Error;\n    const reason = await result.json().catch((r) => {\n        return new Error(`${result.status} ${result.statusText} for ${path}`);\n    });\n\n    if (!(reason instanceof Error)) {\n        const t = new Error(`${result.status} ${result.statusText} for ${path}`);\n        t.cause = result;\n        throw t\n    }\n\n    throw reason\n}\n","import { autobind, StateMachine } from \"@poshplum/utils\";\nimport { EventEmitter } from \"eventemitter3\";\n\nimport { \n    Discovery,\n    ConnectionThresholds,\n } from \"../types/Discovery.js\";\nimport {\n    ChanId,\n    SubscriptionListenerMap,\n    NbhId,\n    ChannelSubscriptionListener,\n    DredChannelMessage,\n    SubscriptionList,\n} from \"../types/ChannelSubscriptions.js\";\nimport { DredHostDetails, connnectionSettings } from \"../types/DredHosts.js\";\nimport { devMessage, DredError, DredEvent } from \"../types/DredEvents.js\";\n\nimport { ConnectionEvent, HostConnection } from \"./HostConnection.js\";\n\nimport {\n    ConnectionState,\n    ConnectionManagerOptions,\n    PromisedHostDetails,\n    ThresholdChoice,\n} from \"../types/PeerDiscovery.js\";\nimport { asyncDelay } from \"../util/asyncDelay.js\";\nimport { fetcher } from \"./fetcher.js\";\nimport { DredMessage } from \"./DredClient.js\";\n\n//!!! todo zw3w737: it has a way of posting the same unique message to multiple servers,\n//     ... and for that message to converge across them all.\n\n\ntype ManagerEvents = {\n    hasNeighborhood: [DredEvent];\n    needsNeighborhood: [DredEvent];\n    connecting: [DredEvent];\n    \"connect:minimal\": [DredEvent];\n    connected: [DredEvent];\n    disconnecting: [DredEvent];\n    disconnected: [DredEvent];\n\n    //! todo: move these to an aggregator capability in Client or separate class\n    \"channel:added\": [DredEvent & { nbh: NbhId; channel: ChanId }];\n    \"channel:removed\": [DredEvent & { nbh: NbhId; channel: ChanId }];\n    message: [DredChannelMessage];\n};\n\ntype connStatus = \"active\" | \"pending\" | \"disconnected\" | \"obsolete\";\ntype healthStatus = \"unhealthy\" | \"partial\" | \"healthy\";\n\ntype cm = ConnectionManager;\nconst connectionManagerStates = {\n    logLevel: \"info\",\n    discoveringNbh: {\n        default: true,\n        async onEntry(this: cm) {\n            //! it moves directly to host discovery if there is already a nbh\n            if (this.discovery.hasNeighborhood()) {\n                return this.transition(\"setupPending\");\n            } else {\n                this.events.emit(\"needsNeighborhood\", {\n                    message: \"select a neighborhood\",\n                    // recommendation: \"\",\n                    [devMessage]: [\n                        \"choose a default neighborhood if that fits your application's needs, \",\n                        \"and/or give the user a default or choice based on neighborhood discovery.\",\n                        \"Set a default neighborhood with the new DredClient{{neighborhood}) option\",\n                        \"...or, use clientObject.discovery.setNeighborhood(nbhId)\",\n                    ]\n                });\n            }\n        },\n        setupPending: \"pendingSetup\",\n        updatedHostList: \"pendingSetup\",\n    },\n    pendingSetup: {\n        async onEntry(this: cm) {\n            if (!this.channelSubs?.size) {\n                console.log(\"     ConnectionManager: pendingSetup: deferred until channel subscriptions are set\");\n                return\n            }\n            const hosts = this.discovery.hosts;\n            if (hosts?.length && !this.hosts) {\n                this.hosts = hosts;\n            }\n\n            if (this.hosts?.length)\n                return this.transition(\"readyToConnect\");\n            \n            console.log(\"      pendingSetup: waiting for host discovery\");\n        },\n        updatedHostList: { nextState: \"pendingSetup\", reEntry: true },\n        hasSubscriptions: { nextState: \"pendingSetup\", reEntry: true },\n        readyToConnect: \"connecting\",\n        disconnected: {\n            // predicate() {\n            //     console.log(new Error(\"stack\"))\n            //     debugger\n            //     return true;\n            // },\n            nextState: \"disconnected\"\n        }\n    },\n    replacingSubs: {\n        // equivalent to connecting, except:\n        //   * quieter (no separate \"connecting\" event)\n        partial: \"degraded\",\n        sufficient: \"healthy\",\n    },\n    connecting: {\n        onEntry(this: cm) {\n            this.events.emit(\"connecting\", {\n                message: \"establishing connections to neighborhood hosts\",\n                [devMessage]: [\n                    `The connection manager is starting to connect to hosts.`,\n                    `Update users with the info and monitor other events for further progress`,\n                ],\n            });\n            this.connectToHosts();\n        },\n        updatedHostList: {\n            nextState: \"connecting\",\n            reEntry: true,\n        },\n        partial: \"partiallyConnected\",\n        replaceSubs: \"replacingSubs\",\n    },\n    partiallyConnected: {\n        onEntry(this: cm) {\n            this.emitPartialConnectEventIfNeeded();\n        },\n        // \"connectedOne\": \"addedConnection\",\n        sufficient: \"healthy\",\n        partial: \"partiallyConnected\",\n    },\n    healthy: {\n        onEntry(this: cm) {\n            //@ts-expect-error - until state-machine provides us an indicator of previous state\n            if (this.previousState) throw new Error(\"hurray, we can change this next line\");\n            const previousState = this.currentState as string;\n\n            //! it notifies interested clients when the connection count has become sufficient.\n            if ([\"disconnected\", \"degraded\"].includes(previousState)) {\n                this.events.emit(\"connected\", {\n                    message: \"restored neighborhood connectivity\",\n                    //! it helps clients clear any warnings that may have been present\n                    //  for security / realtime applications\n                    altMessageSecurity: \"\",\n                    altMessageRealtime: \"\",\n                    [devMessage]: \"consider displaying the message briefly, to reassure the user\",\n                });\n            } else {\n                this.events.emit(\"connected\", {\n                    message: \"connected to neighborhood\",\n                    //!!! todo? include a count of connected hosts, here or in another spot\n                    //   ... even if that's only for dApp developer transparency and we guide them\n                    //   to avoid creating unnecessary complication by default in their UX\n\n                    //! it helps clients clear any warnings that may have been present\n                    //  for security / realtime applications\n                    altMessageSecurity: \"\",\n                    altMessageRealtime: \"\",\n                    [devMessage]: \"consider displaying the message briefly, to reassure the user\",\n                });\n            }\n        },\n        sufficient: {\n            //! it can withstand being transitioned (back) to sufficient any time the active\n            //  connection-count changes, without triggering extraneous events\n            nextState: \"healthy\",\n            reEntry: false,\n        },\n        partial: \"degraded\",\n        updatedHostList: \"connecting\",\n    },\n    degraded: {\n        onEntry(this: cm) {\n            this.events.emit(\"connect:minimal\", {\n                message: \"...trying to improve neighborhood connectivity\",\n                altMessageRealtime: \"messages may be delayed\",\n                altMessageSecurity:\n                    \"for improved security, please hold while connectivity is restored\",\n                [devMessage]: [\n                    `The connection manager still has some connections to neighborhood hosts,`,\n                    ` ... but fewer than preferred for redundancy, security, and tolerance to further faults.`,\n                    `Realtime or security-critical applications may consider using one of the altMessages and/or 'message'.`,\n                    `The connection manager will retry and add connections to other neighborhood hosts if possible,`,\n                    ` ... to re-achieve a healthy level of connectivity; it will issue a 'connected' event at that time`,\n                ],\n            });\n        },\n        sufficient: \"sufficient\",\n        updatedHostList: \"connecting\",\n    },\n    disconnecting: {\n        onEntry(this: cm) {\n            this.events.emit(\"disconnecting\", {\n                message: \"disconnecting from neighborhood hosts\",\n                [devMessage]: [`disconnecting on request (probably from client object)`],\n            });\n            this.disconnect();\n        },\n        disconnected: \"disconnected\",\n    },\n    disconnected: {\n        async onEntry(this: cm) {\n            //!!! todo: check prior state and tune the message to fit those conditions.\n\n            this.events.emit(\"disconnected\", {\n                message: \"we're having trouble maintaining neighborhood connectivity\",\n                recommendation: \"check your network connection and/or have patience\",\n                altMessageRealtime: \"you may experience messaging delays\",\n                altMessageSecurity: \"wait for resolution before continuing\",\n                [devMessage]: [\n                    \"tbd\"\n                ]\n            });\n        },\n        reconnect: \"connecting\",\n    },\n};\n\nexport class ConnectionManager extends StateMachine.withDefinition(\n    connectionManagerStates,\n    \"connection-manager\"\n) {\n    state: ConnectionState = \"pending\";\n    discovery: Discovery;\n    hosts?: DredHostDetails[];\n    events = new EventEmitter<ManagerEvents>();\n    waitFor: ThresholdChoice;\n\n    getThresholds(): Promise<ConnectionThresholds> {\n        return this.discovery.getConnectionThresholds();\n    }\n    //! it keeps a current list of target event-subscriptions\n    channelSubs?: SubscriptionListenerMap;\n\n    //! it remembers the last set of subscriptions, while the next set is being established.\n    lastChannelSubs?: SubscriptionListenerMap;\n\n    //! it is initialized with connection settings used for tuning behavior of outgoing connections\n    connectionSettings: connnectionSettings;\n\n    //! it can map from the host object to a best-known Connection object for that host.\n    private hostToConn = new Map<DredHostDetails, HostConnection>();\n\n    //! it keeps notes on the status of every connection it knows about, and can count the connections in each state\n    private connStatus = new Map<HostConnection, connStatus>();\n\n    //! it keeps a graveyard of connections that can drop out of the set anytime they're garbage-collected,\n    //  for connections that are known to be obsolete / replaced by newer versions, but which might still get / emit\n    //  some events while they wrap up their operations.\n    private graveyard = new WeakSet<HostConnection>();\n\n    private partialConnectNotification?: Promise<any>;\n\n    private _status!: string; // assigned by state-machine\n    //@ts-expect-error -  base class has void as return type.  fix when state machine gets typescript love.\n    set currentState(v: string) {\n        this._status = v;\n    }\n    //@ts-expect-error -  base class has void as return type.  fix when state machine gets typescript love.\n    get currentState() {\n        return this._status || this.defaultState;\n    }\n    channels?: ChanId[];\n\n    constructor(options: ConnectionManagerOptions) {\n        super({\n            contextLabel: \"connection-manager\",\n            currentState: \"discoveringNbh\",\n            logFacility: \"connection-manager:state\",\n            contextObject: null,\n        });\n        // //@ts-expect-error used before assignment (assigned by state-machine)\n        // this._status = this._status || \"\";\n\n        this.connectionSettings = HostConnection.settingsWithDefaults(options.connectionSettings);\n        this.discovery = options.discovery;\n        this.discovery.events.on(\"hosts:updated\", this.setHostList);\n        this.waitFor = options.waitFor;\n        this.transition(\"default\");\n        // .then(() => {\n        //     console.log(\"AFTER transition, post ConnectionManager constructor\", options);\n        // })\n    }\n\n    @autobind\n    async setHostList({ hosts: newHosts }: { hosts: DredHostDetails[] }) {\n        if (this.hosts) {\n            this.retireObsoleteConnections(newHosts);\n        }\n        this.hosts = newHosts;\n        this.transition(\"updatedHostList\");\n    }\n\n    retireObsoleteConnections(updatedHosts: DredHostDetails[]) {\n        //!!! todo: implement retireObsoleteConnections\n\n        //! it removes connections to hosts that aren't in the updated host list.\n    }\n\n    async getChannelList(): Promise<ChanId[]> {\n        // if (this.channels) return this.channels;\n        //!!! todo: ensure that channels are always fresh (watch host connections for updates in '_chans' stream)\n        if (!this.hosts) {\n            if (this.discovery.hosts?.length) {\n                this.hosts = this.discovery.hosts;\n            } else {\n                throw new Error(`no hosts discovered yet`);\n            }\n        }\n\n        const channels = new Set<string>();\n        let hostNumber = 1;\n        let responses = 0;\n        let completed = false;\n        let errors : Error[] = [];\n        for (const host of this.hosts as DredHostDetails[]) {\n            if (hostNumber > 2) await asyncDelay(100 * Math.pow(1.27, hostNumber));\n\n            try {\n                const {channels:foundChans} = await fetcher(\"/channels\", {\n                    host,\n                })\n                for (const chan of foundChans) {\n                    if (!channels.has(chan)) {\n                        this.events.emit(\"channel:added\", {\n                            nbh: this.discovery.nbh,\n                            channel: chan,\n                            message: \"new channel discovered\",\n                            [devMessage]: [\n                                \"ensure this channel makes it into the state of the client & application\",\n                            ],\n                        });\n                    }\n                    channels.add(chan);\n                }\n                return (this.channels = [...channels]);\n            } catch(e) {\n                console.warn(`host ${host.address}:${host.port}: fetching /channels failed: `, e)\n            }\n        }\n        return []\n    }\n\n    // async getPeers(): PromisedPeers<T> {\n    //     if (this.peerCache) return this.peerCache;\n    //     return (this.peerCache = await this.discovery.getHostList());\n    // }\n    // async _discover(): PromisedPeers<T> {\n    //     this.state = \"discovering\";\n    //     return this.discoverPeers();\n    // }\n    disconnect() {\n        //! it tells each host connection to disconnect\n        for (const [host, connection] of this.hostToConn.entries()) {\n            connection.disconnect(\"due to connection manager disconnect()\");\n            this.moveConnTo(connection, \"obsolete\");\n        }\n        this.transition(\"disconnected\");\n    }\n\n    async setSubscriptions(subs: SubscriptionListenerMap) {\n        if (this.channelSubs) return this.replaceSubscriptions(subs);\n\n        this.channelSubs = subs;\n        if (!this.hosts) {\n            if (this.discovery.hosts?.length) {\n                this.hosts = this.discovery.hosts;\n            } else {\n                console.log(\"setSubscriptions: waiting for hosts:ready from discovery\");\n                await new Promise((resolve) => this.discovery.events.once(\"hosts:ready\", resolve));\n            }\n        }\n        this.connectToHosts();\n        return subs\n    }\n\n    async replaceSubscriptions(subs: SubscriptionListenerMap) {\n        this.lastChannelSubs = this.channelSubs;\n        this.channelSubs = subs;\n\n        const promises: Promise<any>[] = [];\n        for (const host of this.hostToConn.keys()) {\n            promises.push(this.replaceHostConnection(host));\n        }\n        // these promises will resolve within settings.connectionWaitTime,\n        // although IF enough of the connections haven't gotten started yet, then\n        // the connection manager will change to\n        Promise.all(promises).then( () => {\n            this.lastChannelSubs = undefined;\n        })\n        return subs;\n    }\n\n    connectToHosts() {\n        if (!this.hosts) {\n            if (this.discovery.hosts?.length) {\n                this.hosts = this.discovery.hosts;\n            } else {\n                throw new Error(`no hosts; discovery not complete?`);\n            }\n        }\n\n        for (const h of this.hosts) {            \n            const foundConn = this.hostToConn.get(h);\n\n            if (foundConn) {\n                //!! todo: it recycles host connections, if they have a full match with current channelSubs\n                this.replaceHostConnection(h);\n            } else {\n                this.connectTo(h);\n            }\n        }\n    }\n\n    connectTo(host: DredHostDetails) {\n        if (!this.channelSubs)\n            throw new Error( // makes typescript happy\n                `missing channelSubs; should already have a reasonable default value`\n            );\n            \n        //! it gathers a list of channels and subscription settings to use for this conection\n        const subscriptions : SubscriptionList = [];\n        for (const sub of Object.values(this.channelSubs)) {\n            subscriptions.push(sub.options)\n        }\n        const conn = new HostConnection(host, subscriptions, this.connectionSettings);\n        conn.events.on(\"connected\", this.healthyConnection);\n\n        conn.events.on(\"disconnected\", this.cleanupConnection);\n        conn.events.on(\"replacedBy\", this.cleanupConnection);\n        conn.events.on(\"failed\", this.cleanupConnection);\n\n        conn.events.on(\"message\", this.notifySubscribers);\n\n        //!!! todo c1hxed4: consider use-cases in order to to ensure that any important needs of connection manager's\n        //     responsibility are appropriately served by observing and acting on these warnings.  That might range\n        //     from applying heuristics for particular sub-types of warning, to exposing warnings to the client\n        //     for presentation to users.\n        // conn.events.on(\"warning\", this.notifySubscribers);\n\n        this.hostToConn.set(host, conn);\n        this.moveConnTo(conn, \"pending\");\n        return conn;\n    }\n\n    logger!: any;\n    @autobind\n    healthyConnection(event: ConnectionEvent) {\n        const { connection, message: msg } = event;\n        //! it records the active state of the connection\n        this.moveConnTo(connection, \"active\");\n        this.logger.info({ summary: `connection to ${connection.host.address}` }, \"healthy\");\n\n        //! it does NOT need to trigger event 'replacedBy', because replaceHostConnection() takes that responsibility\n\n        this.checkConnectionState();\n    }\n\n    @autobind\n    cleanupConnection(event: ConnectionEvent | DredError) {\n        const { connection, message } = event;\n        console.log(\"cleanup: \", connection.host.address, message);\n\n        this.moveConnTo(connection, \"disconnected\");\n        this.graveyard.add(connection);\n    }\n\n    @autobind\n    notifySubscribers(event: ConnectionEvent & DredChannelMessage & DredMessage) {\n        const { channel } = event;\n        if (!this.channelSubs) {\n            console.log(\"no listeners to hear about:\", event);\n            return;\n        }\n        const sub = this.channelSubs[channel];\n        sub?.notify(event)\n    }\n\n    async replaceHostConnection(host: DredHostDetails): Promise<HostConnection> {\n        const replacingConn = this.hostToConn.get(host);\n\n        const replacement = this.connectTo(host);\n        //! it starts a replacement connection and hopes to complete the new connection quickly.\n        return new Promise<HostConnection>((resolve, reject) => {\n            let timeout: boolean;\n            replacement.events.once(\"connected\", ({ connection }) => {\n                const oldConnection = replacingConn;\n                //! if it completes quickly, the original connection is seamlessly replaced in the active-connections list\n                oldConnection?.replacedBy(replacement);\n                //! if the connection didn't connect promptly and was moved to pending, it's made active when connected\n                this.moveConnFromTo(replacement, \"pending\", \"active\");\n                //! it moves the old connection\n                oldConnection && this.moveConnTo(oldConnection, \"obsolete\");\n                oldConnection && this.graveyard.add(oldConnection);\n\n                if (!timeout) {\n                    timeout = false;\n                    resolve(replacement);\n                }\n            });\n            //! if the new connection doesn't connect promptly, it...\n            //   * moves the old connection to obsolete\n            //   * adds the pending connection to pending\n            //   * triggers replacedBy event on the prior connection\n            //   * has a clear outlet/codepath for completing the resolution of the new connection (same as for any connection)\n            asyncDelay(this.connectionSettings.connectionWaitTimeMs).then(() => {\n                this.moveConnTo(replacement, \"pending\");\n                const oldConnection = replacingConn;\n                oldConnection && this.moveConnTo(oldConnection, \"obsolete\");\n                if (timeout !== false) {\n                    timeout = true;\n                    resolve(replacement);\n                }\n            });\n        });\n    }\n\n    connected(connection: HostConnection, event: DredEvent) {\n        const status = this.connStatus.get(connection);\n        if (status == \"obsolete\") return;\n        this.moveConnTo(connection, \"active\");\n\n        const obsoleteConn = this.hostToConn.get(connection.host);\n        if (obsoleteConn) {\n            this.moveConnTo(obsoleteConn, \"obsolete\");\n        }\n        this.hostToConn.set(connection.host, connection);\n    }\n\n    //! it sets the status of a connection to a target state, only if the current state matches the indicated \"from\" state.\n    private moveConnFromTo(connection: HostConnection, from: connStatus, target: connStatus) {\n        const current = this.connStatus.get(connection);\n        if (from === current) this.connStatus.set(connection, target);\n    }\n\n    //! it moves the connection to a target state\n    private moveConnTo(connection: HostConnection, state: connStatus) {\n        this.connStatus.set(connection, state);\n    }\n\n    //! it emits a \"connect:minimal\" event after a brief delay, only if it's still\n    //  partially-connected after other connections have had their chance\n    //  and it didn't make it to a well-connected state.\n    async emitPartialConnectEventIfNeeded() {\n        if (this.partialConnectNotification) return;\n\n        const unhappy: ConnectionState[] = [\"degraded\", \"minimally connected\"];\n\n        const pcn = (this.partialConnectNotification = asyncDelay(\n            this.connectionSettings.connectionWaitTimeMs\n        ));\n        await pcn;\n\n        if (unhappy.includes(this.state) && pcn === this.partialConnectNotification) {\n            this.partialConnectNotification = undefined;\n            this.events.emit(\"connect:minimal\", {\n                message: \"partially connected to neighborhood\",\n                altMessageRealtime: `message delays are possible`,\n                [devMessage]: [\n                    `There are a minimal number of connections to neighborhood hosts,`,\n                    ` ... but not as many as would be preferred for best operations.`,\n                    `Connection manager will work to restore connectivity.  Look for the 'connected' event`,\n                    ` ... to indicate restored health.`,\n                    `For security-centric applications, the minimal number of connections should`,\n                    ` ... already guard security outcomes, so this event does not imply a loss of security`,\n                ],\n            });\n        }\n    }\n\n    async checkConnectionState(): Promise<healthStatus> {\n        //! it checks all the peers for connection health\n        const thresholds = await this.getThresholds();\n        let healthyConnectionCount = 0;\n\n        for (const [conn, status] of this.connStatus.entries()) {\n            if (this.graveyard.has(conn)) continue;\n\n            if (status === \"active\") healthyConnectionCount += 1;\n        }\n\n        if (healthyConnectionCount >= thresholds.healthy) {\n            return this.transition(\"sufficient\");\n        }\n\n        if (healthyConnectionCount > thresholds.minimal) {\n            return this.transition(\"partial\");\n        }\n        return this.transition(\"unhealthy\");\n    }\n\n    async freshenPeers(): PromisedHostDetails {\n        this.state = \"refreshing\";\n        const newCache = await this.discovery.getHostList();\n        if (newCache === this.hosts) {\n            throw new Error(\n                `discoverPeers returned the existing perCache; it must return a new Peer list`\n            );\n        }\n        let i = 0;\n        for (let newPeer of newCache) {\n            const match = this.hosts?.find((cachedPeer) => this.areSamePeer(newPeer, cachedPeer));\n            if (match) {\n                newPeer = newCache[i] = match;\n            }\n            // if (!newPeer.isConnected || newPeer.isConnecting) {\n            //     await newPeer.abortConnection();\n            //     await newPeer.connect();\n            // }\n        }\n        //!!! it counts good connections and keeps health-state accurate\n        //    in its state-machine - so this probably isn't needed\n        // await this.checkConnectionState(newCache)\n        return (this.hosts = newCache);\n    }\n\n    newState(cs: ConnectionState) {\n        this.state = cs;\n\n        //!!! add eventListener and notify those listeners.\n        // this.notify(cs);\n    }\n\n    // async connectToPeers(): PromisedHostDetails {\n    //     const promises: Array<Promise<Peer<T>>> = [];\n    //     const connectedPeers: DredHostDetails[];\n    //     const peers = this.freshenPeers();\n    //     const thrs = await this.getThresholds();\n\n    //     let startTime = new Date().getTime(),\n    //         resolver: Function,\n    //         rejecter: Function,\n    //         resolved: Boolean,\n    //         rejected: Boolean,\n    //         seenErrors: Error[],\n    //         successCount = 0,\n    //         rejectCount = 0;\n\n    //     function resolveMe(result) {\n    //         if (resolved || rejected) return;\n    //         resolved = true;\n    //         resolver(result);\n    //     }\n    //     function rejectMe(error) {\n    //         if (resolved || rejected) return;\n    //         rejected = true;\n    //         rejecter(error);\n    //     }\n\n    //     const checkPartialSuccess = () => {\n    //         //! it resolves immediately when enough successes have accumulated,\n    //         //   compared to the requested 'waitFor' threshold.\n    //         if (connectedPeers.length > thrs.minimal) {\n    //             //! During initial connection sequence, it notifies listeners as soon as\n    //             //  it has established some connectivity, for progress reporting to end-user.\n    //             this.optionalTransition(\"partial\");\n    //         }\n    //         if (connectedPeers.length >= thrs[this.waitFor]) {\n    //             console.log(\"connected to peers\", connectedPeers.length);\n\n    //             resolveMe(peers);\n    //         }\n\n    //         //! it throws an error if it can't connect to enough peers\n    //         if (peers.length - rejectCount < thrs.minimal) {\n    //             console.error(\"Error connecting to enough peers\");\n    //             if (successCount) {\n    //                 this.newState(\"underconnected\");\n    //                 const msg = `Connected to only ${successCount} peers, out of ${thrs.minimal} needed for convergence`;\n    //                 console.error(msg);\n    //                 //!!! todo: consider: in development, we should fake a cycle through all possible states\n    //                 rejectMe(\n    //                     new Error(msg, {\n    //                         cause: {\n    //                             partial: true,\n    //                             \"?developer?\": {\n    //                                 note: \"more peers can connect later, and any reconnecting peers may result in a later improvement\",\n    //                                 guidance:\n    //                                     \"don't let the user think everything is fine and dandy!  Not having enough connectivity for convergence means YOU DON'T KNOW THE STATE OF THE CHANNEL!\",\n    //                             },\n    //                             seenErrors,\n    //                             recommendation:\n    //                                 \"Warn the user with this error.message, and use a read-only UI until decentralization score improves\",\n    //                             suggestion:\n    //                                 \"consider rendering any locally-cached data if possible and use a read-only or offline state in your user-experience\",\n    //                         },\n    //                     })\n    //                 );\n    //             } else if (this.state == \"connecting\") {\n    //                 const msg = `Not connected to any peers`;\n    //                 console.error(msg);\n    //                 this.newState(\"disconnected\");\n    //             }\n    //             //!!! todo: make the following details available under this.getMoreInfo\n    //             //     and this.developerGuidance\n    //             const msg = `Can't connect to any peers. ${thrs.minimal} are needed for convergence`;\n    //             console.error(msg);\n    //             rejectMe(\n    //                 new Error(msg, {\n    //                     cause: {\n    //                         partial: false,\n    //                         note: \"Reconnecting peers may result in a later improvement\",\n    //                         guidance:\n    //                             //!!! guides developer to use reconnect() or its final and correct name\n    //                             \" wait for retries to succeed, or use reconnect()\",\n    //                         seenErrors,\n    //                         recommendation:\n    //                             \"Emit this error.message into your UI, and keep monitoring for continuing state changes\",\n    //                         suggestion:\n    //                             \"consider rendering any locally-cached data if possible and use a read-only or offline state\",\n    //                     },\n    //                 })\n    //             );\n    //         }\n\n    //         const now = new Date().getTime();\n    //         //@ts-expect-error - remove the fallback and/or adjust the code to get same result\n    //         //   out of the state machine\n    //         if (now - startTime > this.connectionSettings.connectionWaitTimeMs || 5000) {\n    //             //! resolves successfully if it can connect to at least the minimal number of peers\n    //             //   after waiting for the timeout, even if waitFor: \"healthy\" is specified.\n    //             if (successCount > thrs.minimal) {\n    //                 resolveMe(peers);\n    //             }\n    //         }\n    //     };\n\n    //     const myPromise = new Promise((res, rej) => {\n    //         (resolver = res), (rejecter = rej);\n    //     }) as PromisedHostDetails;\n    //     for (const p of peers) {\n    //         let retries = 0;\n    //         let myLastError: Error;\n    //         const pp = this.tryOneConnection(p).then(\n    //             () => {\n    //                 console.log(\"connected to peer\", p);\n    //                 if (resolved) return;\n\n    //                 successCount += 1;\n    //                 connectedPeers.push(p);\n    //                 checkPartialSuccess();\n    //             },\n    //             (error) => {\n    //                 rejectCount += 1;\n    //                 seenErrors.push(error);\n    //                 myLastError = error;\n    //                 checkPartialSuccess();\n\n    //                 //! retries any failed connections\n    //                 this.tryOneConnection(p).then(\n    //                     (success) => {\n    //                         console.log(\"CM: success after retry on peer\", p);\n    //                         //! todo: write the real code for this:\n    //                         //   seenErrors.deleteAt(myLastError):\n    //                         rejectCount -= 1;\n    //                         successCount += 1;\n    //                         checkPartialSuccess();\n    //                     },\n    //                     (failure) => {\n    //                         console.log(\"CM: giving up after one retry on peer\", p);\n    //                         //! for now, it retries each connection only once.\n    //                         //!!! todo: use exponential retry (exponents of 1.27 starting at ~500ms)\n    //                     }\n    //                 );\n    //             }\n    //         );\n    //         promises.push(pp as any);\n    //     }\n\n    //     return myPromise;\n    // }\n    areSamePeer(p1: DredHostDetails, p2: DredHostDetails) {\n        return (\n            p1.address == p2.address &&\n            p1.port == p2.port &&\n            p1.serverId == p2.serverId &&\n            p1.publicKey == p2.publicKey\n        );\n    }\n}\n","// import nacl from \"tweetnacl\";\n// const { sign: slowSyncSign } = nacl;\n// const { verify: slowSyncVerify } = slowSyncSign;\n\nimport util from \"tweetnacl-util\";\nconst { encodeUTF8, decodeUTF8, encodeBase64, decodeBase64 } = util;\nimport { newKeyPair, sign, verify } from \"watsign\";\n\ntype LoggerType = {\n    log: Function;\n    warn: Function;\n};\nexport class StringNacl {\n    static newKeyPair = newKeyPair;\n    identity?: nacl.SignKeyPair;\n    logger: LoggerType;\n    constructor(keyPair?: nacl.SignKeyPair, logger: LoggerType = console) {\n        this.identity = keyPair;\n        this.logger = logger;\n    }\n    async sign(s: string): Promise<string> {\n        if (!this.identity)\n            throw new Error(`StringNacl: missing keyPair for signing`);\n        const buf = decodeUTF8(s);\n        const sigBuf = await sign(buf, this.identity.secretKey);\n        const sigStr = encodeBase64(sigBuf);\n        return sigStr;\n    }\n\n    async verifySig(\n        s: string,\n        sigBase64: string,\n        keyBase64: string\n    ): Promise<boolean> {\n        let strBuf: Uint8Array, sigBuf: Uint8Array, keyBuf: Uint8Array;\n        try {\n            strBuf = decodeUTF8(s);\n        } catch (e: any) {\n            this.logger.warn(\"failure to decode string:\", e.message);\n            return false;\n        }\n        try {\n            sigBuf = decodeBase64(sigBase64);\n        } catch (e: any) {\n            this.logger.warn(\"failure to decode signature:\", e.message);\n            return false;\n        }\n        try {\n            keyBuf = decodeBase64(keyBase64);\n        } catch (e: any) {\n            this.logger.warn(\"failure to decode pubkey:\", e.message);\n            return false;\n        }\n        return verify(strBuf, sigBuf, keyBuf);\n    }\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport { NbhId } from \"./ChannelSubscriptions.js\";\nimport { devMessage, DredEvent } from \"./DredEvents.js\";\nimport { DredHostDetails } from \"./DredHosts.js\";\n\nexport interface discovery {\n    getHostList(): Promise<DredHostDetails[]>;\n    getNeighborhoods(): Promise<string[]> | never ;\n}\n\nexport type findingDredHosts = Promise<DredHostDetails[]>;\nexport interface DiscoveryEvents {\n    \"hosts:discovering\": [DredEvent & {nbh: NbhId}]\n    \"hosts:ready\": [DredEvent & {nbh: NbhId, hosts: DredHostDetails[]}]\n    \"hosts:updated\": [DredEvent & {nbh: NbhId, hosts: DredHostDetails[]}]\n}\nexport interface GenericDiscoveryOptions {\n    neighborhood?: NbhId\n}\nexport abstract class Discovery implements discovery {\n    nbh!: string; // neighborhood\n    hosts?: DredHostDetails[];\n    events = new EventEmitter<DiscoveryEvents>();\n    //! finds a list of hosts that serve the given neighborhood.\n    abstract getHostList() : findingDredHosts;\n\n    //! finds available neighborhoods through its discovery mechanism, if any.  \n    //    throws an error if it doesn't implement nbh discovery.\n    async getNeighborhoods(): Promise<NbhId[] > | never {\n        throw new Error(`this discovery protocol doesn't implement getNeighborhoods().  instantiate it with a predefined neighborhood name instead.`)\n    };\n    abstract getConnectionThresholds(): Promise<ConnectionThresholds>;\n\n    constructor(options : GenericDiscoveryOptions) {\n        const {neighborhood} = options\n        if (neighborhood) this.setNeighborhood(neighborhood);\n\n        //! it prevents subclasses from overriding restartHostDiscovery() logic; see initHostDiscovery() instead.\n        if (this.restartHostDiscovery !== Discovery.prototype.restartHostDiscovery) {\n            throw new Error(`restartHostDiscovery must not be overridden by Discovery subclass `+ this.constructor.name)\n        }\n    };\n\n    hasNeighborhood() : boolean {\n        return !!this.nbh;\n    }\n\n    //! it allows concrete subclasses to implement custom behavior during initHostDiscovery()\n    async initHostDiscovery() {\n    }\n\n    protected async restartHostDiscovery() {\n        if (!this.nbh) throw new Error(`can't start host discovery without nbh`);\n\n        //!!! todo: it emits a host-discovery-timeout event if hosts can't be discovered promptly.\n\n        await this.initHostDiscovery();\n        this.events.emit(\"hosts:discovering\", {\n            message: \"discovering neighborhood hosts...\",\n            nbh: this.nbh,\n            [devMessage]: \"suggested: update user with this status message\"\n        });\n        const hosts = await this.getHostList();\n        const e = {\n            hosts,\n            message: `found ${hosts.length} hosts serving neighborhood`,\n            nbh: this.nbh,\n            [devMessage]: \"suggested: update user with this status message\"\n        }\n        if (!this.hosts) {\n            this.events.emit(\"hosts:ready\", e)\n        }\n        this.hosts = hosts;\n        this.events.emit(\"hosts:updated\", e)\n    }\n    setNeighborhood(nbh : NbhId) {\n        this.nbh = nbh;\n        this.restartHostDiscovery();\n        return this;\n    }\n    reset(newHosts: DredHostDetails[]=[]) {\n        this.hosts = newHosts;\n        return this;\n    }\n    async myServerInfo(serverId: string): Promise<DredHostDetails | undefined> {\n        const hosts = await this.getHostList();\n        return hosts.find(x => serverId == x.serverId);\n    }    \n}\n\n\n\nimport { connnectionSettings } from \"./DredHosts.js\";\n\nexport type ConnectionManagerOptions = {\n    discovery: Discovery;\n    waitFor: ThresholdChoice,\n    connectionSettings: connnectionSettings\n};\n\nexport type ConnectionThresholds = {\n    minimal: number;\n    healthy: number;\n};\nexport type ThresholdChoice = keyof ConnectionThresholds\nexport type promisedConnectionThresholds = Promise<ConnectionThresholds>;\n\nexport type ConnectionState =\n    | \"pending\"\n    | \"discovering\"\n    | \"connecting\"\n    | \"disconnected\"\n    | \"underconnected\"\n    | \"minimally connected\"\n    | \"connected\"\n    | \"refreshing\";\n","import { NbhId } from \"../types/ChannelSubscriptions.js\";\nimport { ConnectionThresholds, Discovery, findingDredHosts, GenericDiscoveryOptions, promisedConnectionThresholds } from \"../types/Discovery.js\";\n\nexport class NeighborhoodDiscovery extends Discovery {\n    neighborhood?: NbhId;\n    static forNeighborhood(n: string) {\n        return new this({neighborhood: n});\n    }\n    constructor(options: GenericDiscoveryOptions) {\n        const {neighborhood} = options;\n        super(options);\n        if (neighborhood) this.neighborhood = neighborhood;\n    }\n    async getNeighborhoods() {\n        return [\"cardano-after-dark\"]; //!!! todo: use discovery service to find registered neighborhoods\n    }\n    async getHostList(): findingDredHosts {\n        console.warn(`Discovery in neighborhood has no impl yet.  Try DevEnvLocalDiscovery for now`);\n        return [];\n    }\n\n    async getConnectionThresholds() : promisedConnectionThresholds {\n        //!!! todo: revisit this, perhaps with neighborhood-specific preferences found in discovery,\n        //   or by punting to the application.\n    \n        return this.clientRedundancyThresholds();\n    }\n    async serverRedundancyThresholds() : promisedConnectionThresholds {\n        if (!this.hosts) { throw new Error(`no this.hosts`) }\n\n        const count = this.hosts.length;\n        if (count > 7) {\n            return {\n                minimal:1+Math.floor(count/2), \n                healthy: Math.ceil(count * 2 / 3)\n            }\n        }\n        if (count > 2) {\n            // 3  => need 2, want 3;\n            // 4,5  => need 3, want 4;\n            // 6, 7 => need  4, want 5;\n            const minimal = 1 + Math.floor(count / 2);\n            return {\n                minimal, \n                healthy: minimal+1\n            }\n        }\n        if (count > 1) {\n            return {minimal:1, healthy: 2}\n        }\n        return {minimal: 1, healthy: 1}\n    }\n    async clientRedundancyThresholds() : promisedConnectionThresholds{\n        //! it provides some reasonable defaults for getting \"enough\" connectivity\n        //  for clients.  \n    \n        if (!this.hosts) { throw new Error(`no this.hosts`) }\n\n        const count = this.hosts.length;\n        if (count > 7) {\n            return {\n                minimal:3, \n                healthy:4,\n            }\n        }\n        if (count > 3) {\n            return {\n                minimal: 2,\n                healthy: 3\n            }\n        }\n        if (count > 1) {\n            return {minimal:1, healthy: 2}\n        }\n        return {minimal: 1, healthy: 1}\n    }\n\n}\n","import type { DredMessage, DredMessageListener } from \"../client/DredClient.js\";\nimport type { ConnectionEvent } from \"../client/HostConnection.js\";\n\nexport type ChanId = string;\nexport type MsgId = string;\nexport type NbhId = string;\n\nexport type SubscriptionList = ChannelSubOptions[]\nexport type SubscriptionListenerMap = Record<string, ChannelSubscriptionListener>\n\nexport interface ChannelSubEvents {\n    activity: [DredChannelMessage]\n    \"channel:message\": [DredChannelMessage]\n}\n\n//! represents a configuration for monitoring a specific channel\n//! it includes alt-values for optional attributes for developers to easily see \n//  the default behavior if the attribute is omitted\nexport interface ChannelSubOptions {\n    neighborhood: NbhId,\n    channel: ChanId\n    unconfirmed?: true \n        | \"default:only confirmed messages\"\n    summary?: true \n        | \"default:include message details\"\n    interval?: number \n        | \"default:notify in realtime\"\n    onlyFields?: string[] \n        | \"default:include all fields in details\"\n    filter?: {\n        //! todo: allows messages to be filtered on field attributes with $gt, $gte, $lt, $lte, $in, $nin.\n    }\n}\n\n\ntype DredMsgData = string;\nexport type DredChannelMessage = ConnectionEvent &  {\n    message: \"msg received in chan\"\n    neighborhood: NbhId,\n    channel: ChanId,\n    msg: DredMsgData,\n    details: any,\n    mid: MsgId,\n    ts: Date,\n}\n\nexport class ChannelSubscriptionListener {\n    options: ChannelSubOptions;\n    recentMsgs!: Set<MsgId>;\n    listener!: DredMessageListener;\n    // XXevents: EventEmitter<ChannelSubEvents>;\n    constructor(options: ChannelSubOptions & { listener: DredMessageListener}) {\n        const {listener, ...rest} = options;\n        this.options = rest;\n        //! it has a recent-messages map, not included in a JSON representation of the subscription\n\n        this.recentMsgs = new Set<MsgId>();\n        this.listener = listener;\n        // this.events = new EventEmitter<ChannelSubEvents>();\n     }\n\n     notify(event : ConnectionEvent & DredChannelMessage & DredMessage) {\n        const { mid: msgId, ocid: originalClientId, connection, message: message, details, neighborhood, channel } = event;\n\n        const seen = this.recentMsgs;\n        if (!seen.has(originalClientId!) && !seen.has(msgId)) {\n            seen.add(msgId);\n            this.listener(event);\n                    // sub.events.emit(\"channel:message\", event);\n        }\n     }\n\n}\n","import fetch from \"cross-fetch\";\nimport { customAlphabet } from \"nanoid\";\nimport nacl from \"tweetnacl\";\nconst { sign } = nacl;\nimport util from \"tweetnacl-util\";\nimport type { Response } from \"cross-fetch\";\n\nconst nanoid = customAlphabet(\"0123456789abcdefghjkmnpqrstvwxyz\", 12);\nimport {colors} from \"../picocolors/picocolors.js\";\nconst {\n    bgBlackBright,\n    blue,\n    blueBright,\n    green,\n    greenBright,\n    red,\n    redBright,\n    yellow,\n    yellowBright,\n    isColorSupported,\n    bgBlack,\n    magenta\n} = colors;\n\nimport EventEmitter from \"eventemitter3\";\nimport { asyncDelay, autobind, StateMachine, zonedLogger } from \"@poshplum/utils\";\n\nimport { ConnectionManager } from \"./ConnectionManager\";\n\nimport { ChannelOptions } from \"../types/ChannelOptions\";\nimport { Subscriber } from \"../Subscriber\";\nimport { StringNacl } from \"../util/StringNacl\";\nimport { connnectionSettings, DredHostDetails } from \"../types/DredHosts\";\nimport { ConnectionThresholds, Discovery } from \"../types/Discovery\";\nimport { NeighborhoodDiscovery } from \"../peers/NeighborhoodDiscovery\";\nimport { HostConnection } from \"./HostConnection\";\nimport {\n    ChanId,\n    SubscriptionListenerMap,\n    ChannelSubscriptionListener,\n    NbhId,\n    DredChannelMessage,\n} from \"../types/ChannelSubscriptions\";\nimport { devMessage, DredError, DredEvent } from \"../types/DredEvents\";\n\nconst { encodeUTF8, decodeUTF8, encodeBase64, decodeBase64 } = util;\n\nexport type DredMessageListener = (dcm: DredChannelMessage & DredMessage) => void;\n\nexport type SubscriberMap = {\n    [k: ChanId]: DredMessageListener;\n};\n\n// export type DredChannelMessage = {\n//     channel: ChanId,\n//     // event: DredMessage,\n// }\n\nexport type DredMessage = {\n    type: string;\n    msg: string;\n    \"content-type\"?: string;\n    ocid?: string;\n    // [key: string]: string | undefined,\n};\nexport type EncryptedDredMessage = DredMessage & {\n    msg: \"encrypted\";\n    encryptedMsg: string;\n};\n\nexport type ClientState = DredEvent & {\n    nbh: NbhId;\n    channels: ChanId[];\n    status: string;\n};\n\nexport type eventHasChannels = DredEvent & {\n    nbh: NbhId;\n    channels: ChanId[];\n};\n\nexport type eventChannelInfo = DredEvent & {\n    nbh: NbhId;\n    channel: ChanId;\n};\n\n// eventemitter3 has a bit of an odd approach on event types, with a wrapping array type needed \n// for each event, probably because the array is used as the expected type of the args-list for the handler.\nexport interface ClientEvents {\n    needsNeighborhood: [ DredEvent & { nbhs: NbhId[] } ];\n    hasChannels: [ eventHasChannels ];\n    needsAuth: [ DredEvent & { tbd: any } ];\n    \"channel:created\": [eventChannelInfo];\n    \"channel:removed\": [eventChannelInfo];\n    \"state:changed\": [DredEvent & ClientState];\n    \"channel:message\": [DredChannelMessage];\n    error: [DredError];\n}\n\nexport interface DredClientArgs {\n    neighborhood?: NbhId;\n    discovery?: Discovery;\n    waitFor: keyof ConnectionThresholds;\n    name?: string;\n    connectionSettings?: Partial<connnectionSettings>;\n}\ntype serverId = string;\ntype connectionMap = Map<serverId, HostConnection>;\ntype subscriberMap = Map<string, Array<Subscriber>>;\nconst nbhChannelList = \"_chans\";\nconst nbhAuthInfo = \"_auth\";\n\nconst logging = parseInt(process.env.LOGGING || \"\");\ntype dred = DredClient;\n\n//! it runs onEntry() and predicate() hooks always in context\n//    of the machine's context-object, which is a DredClient.\nconst clientStates = {\n    // logLevel: \"info\",\n    default: {\n        //! it automatically advances to next states, when it can make progress\n        async onEntry(this: dred) {\n            if (this.args.neighborhood) return this.transition(\"nbhSelected\");\n            return this.transition(\"findNbhs\");\n        },\n        findNbhs: \"findingNbhs\",\n        nbhSelected: \"discoveringHosts\",\n    },\n    findingNbhs: {\n        async onEntry(this: dred) {\n            await this.getNeighborhoods();\n            const next = await this.transition(\"needsNbhSelection\");\n            return;\n        },\n        needsNbhSelection: \"selectingNbh\",\n    },\n    selectingNbh: {\n        async onEntry(this: dred) {\n            this.events.emit(\"needsNeighborhood\", {\n                message: \"select a neighborhood\",\n                [devMessage]: \"Developers: offer these nbhs to a user or pick one by policy.  Call client.setNeighborhood(nbhId) to proceed.\",\n                nbhs: this.availableNeighborhoods,\n            });\n        },\n        nbhSelected: \"discoveringHosts\",\n    },\n    discoveringHosts: {\n        async onEntry(this: dred) {\n            //! it completes the transition WITHOUT waiting for host discovery,\n            // ... and it will continue to channel-discovery later, once hosts are discovered.\n            {\n                this.discovery.getHostList().then(this.mkTransition(\"haveHostList\"));\n            }\n            return;\n        },\n        haveHostList: \"discoveringChannels\",\n    },\n    discoveringChannels: {\n        async onEntry(this: dred) {\n            // this.subscribeToChannels({}); //!!! todo initialize with any pre-existing subs provided to client init\n\n            const chans = await this.connManager.getChannelList();\n            this.channels = chans;\n            await this.transition(\"hasChannels\");\n            this.events.emit(\"hasChannels\", {\n                nbh: this.neighborhoodId,\n                message: \"found channel list\",\n                channels: chans,\n                [devMessage]: [\n                    `The list of channels is ready to present to users, or has been refreshed.`,\n                    `You should reconcile any application-side list of subscribed channels`,\n                ],\n            });\n        },\n        hasChannels: \"ready\",\n    },\n    ready: {\n        async onEntry(this: dred) {\n            // this.\n        },\n    },\n};\n\n/**\n * Creates a new client instance for interacting with a Dred neighborhood.\n * @remarks\n * the client can be initiated with a single message-handler, \n * which is called for all messages received from any channel.\n * set client.messageHandler = ... to use this approach.\n * \n * Alternatively, the client can provide per-channel message-handlers,\n * which are called for messages received from specific channels.\n * Use client.subscribeToChannels({[chanId]: handler}) to set up per-channel handlers.\n */\nexport class DredClient extends StateMachine.withDefinition(clientStates, \"client\") {\n    args: DredClientArgs;\n    events: EventEmitter<ClientEvents> = this.ensureEmitterExists();\n    connManager: ConnectionManager;\n    channels: ChanId[] = [];\n    neighborhoodId: string = \"cardano-after-dark\";\n    availableNeighborhoods: string[] = [];\n    // neighborhoodContractAddress = \"9bef...\";\n    discovery: Discovery;\n    identity?: nacl.SignKeyPair;\n    signer?: StringNacl;\n    pubKeyString?: string;\n    logger: ReturnType<typeof zonedLogger>\n    insecure?: boolean;\n    _subscriptions?: SubscriptionListenerMap;\n    subscribers: subscriberMap = new Map();\n    channelSub?: ChannelSubscriptionListener;\n    authSub?: ChannelSubscriptionListener;\n    messageHandler?: DredMessageListener;\n\n    constructor(args: DredClientArgs) {\n        super({\n            contextLabel: args.name || \"dred-client\",\n            currentState: \"default\",\n            logFacility: \"dred-client:state\",\n            contextObject: null,\n        });\n        this.events = this.ensureEmitterExists();\n        let {name: clientName} = args;\n        clientName = clientName ? `client-${clientName}` : \"dred-client\";\n        this.logger = zonedLogger(clientName, {\n            color: magenta.start,\n            levels: { [clientName]: logging ? \"info\" : \"warn\", _message: `(env LOGGING=${logging})`},\n        });\n\n        //@ts-expect-error used before assignment (assigned by state-machine)\n        this._status = this._status || \"default\";\n\n        this.args = args;\n        const discovery = (this.constructor as typeof DredClient).resolveDiscovery(args);\n        this.discovery = discovery;\n        this.connManager = new ConnectionManager({\n            discovery,\n            waitFor: this.args.waitFor,\n            connectionSettings: this.args.connectionSettings || {},\n        });\n        this.transition(\"default\");\n        //!!! make this test-only\n        // this.insecure = insecure;\n    }\n    private ensureEmitterExists() {\n        return (this.events = this.events || new EventEmitter<ClientEvents>());\n    }\n\n    log(a1: string, ...args: any[]) {\n        this.logger.info(a1, ...args);\n    }\n    warn(a1: string, ...args: any[]) {\n        this.logger.warn(a1, ...args);\n    }\n    setNeighborhood(n: NbhId) {\n        this.neighborhoodId = n;\n        asyncDelay(1).then(this.mkTransition(\"nbhSelected\"));\n    }\n\n    /**\n     * modifies the client's list of channel subscriptions\n     * @remarks\n     * For a client using a single message-handler, call this method with a single channel-id \n     * or a list of channel-ids to subscribe to messages from specific channels.  Throws\n     * a runtime error if there is no message-handler set.\n     * \n     * To use per-channel message-handlers, call this method with a map of channel-ids to \n     * listener functions.  In this case, any assigned messageHandler is not used.\n     */\n    async subscribeToChannels(channels: ChanId[]): Promise<void>;\n    async subscribeToChannels(channel: ChanId): Promise<void>;\n    async subscribeToChannels(smap: SubscriberMap): Promise<void>;\n    async subscribeToChannels(arg: SubscriberMap | ChanId[] | ChanId): Promise<void> {\n        let smap: SubscriberMap;\n        if (Array.isArray(arg)) {\n            if (!this.messageHandler) {\n                throw new Error(\n                    `to use subscribeToChannels with an implicit subscriber, set client's messageHandler first`\n                );\n            }\n            smap = {};\n            for (const channel of arg as ChanId[]) {\n                smap[channel] = this.messageHandler;\n            }\n        } else if (\"string\" === typeof arg) {\n            if (!this.messageHandler) {\n                throw new Error(\n                    `to use subscribeToChannels with an implicit subscriber, set client's messageHandler first`\n                );\n            }\n            smap = { [arg]: this.messageHandler };\n        } else {\n            smap = arg;\n        }\n        this.subscriptions = await this.connManager.setSubscriptions(this.mkChannelSubs(smap));\n    }\n\n    onTransition() {\n        //! tbd if we need to use this hook, perhaps for persisting the bookmark state of channels\n        // debugger\n    }\n\n    static resolveDiscovery({ neighborhood, discovery }: Pick<DredClientArgs, \"neighborhood\" | \"discovery\">): Discovery {\n        if (neighborhood) discovery = new NeighborhoodDiscovery({ neighborhood });\n        if (!discovery) throw new Error(`required: 'discovery' object or 'neighborhood' name`);\n\n        return discovery;\n    }\n\n    private _status: keyof typeof clientStates;\n    //@ts-expect-error -  base class has void as return type.  fix when state machine gets typescript love.\n    set currentState(v: keyof typeof clientStates) {\n        this._status = v;\n        this.emitState();\n    }\n    //@ts-expect-error -  base class has void as return type.  fix when state machine gets typescript love.\n    get currentState() {\n        return this._status;\n    }\n\n    @autobind\n    emitState() {\n        this.ensureEmitterExists();\n        this.events.emit(\"state:changed\", {\n            message: \"client state updated\",\n            [devMessage]:\n                \"no need to show this message onscreen; just update channel-list or status as needed\",\n            nbh: this.neighborhoodId,\n            status: this._status,\n            channels: this.channels,\n        });\n    }\n\n    //! it creates a new subscriptions object\n    //! it recycles existing subscriptions\n    mkChannelSubs(smap: SubscriberMap): SubscriptionListenerMap {\n        const subs: SubscriptionListenerMap = {};\n        subs[nbhChannelList] = this.channelSub = this.getChannelSub(\n            nbhChannelList,\n            this.processChannelsMsg  //! it watches for events relating to channel lifecycle\n        );\n        subs[nbhAuthInfo] = this.authSub = this.getChannelSub(\n            nbhAuthInfo, \n            this.processAuthMsg //! it watches for events relating to authentication lifecycle\n        );\n        for (const [chan, listener] of Object.entries(smap)) {\n            subs[chan] = this.getChannelSub(chan, listener);\n        }\n        return subs;\n    }\n\n    @autobind\n    processChannelsMsg(m: DredChannelMessage) {\n        //!!! todo: it notifies client listeners about created or removed channels\n        //!!! todo: it emits the generic state-updated event with updated channel list\n    }\n\n    @autobind\n    processAuthMsg(m: DredChannelMessage) {\n        //!!! todo: ??? it notifies listeners when authentication is required by one or more neighborhood hosts \n        //     more use-case analysis needed for this.\n\n        //!!! todo: it notifies listeners when a requested channel requires authentication not yet established\n        //     (possibly this would be a responsibility served in a way more aligned with individual channels instead)\n\n        //!!! todo: notifies listening application of new identities joining the neighborhood {type: \"newId\", pubKey, handle, certificates}\n\n        //!!! todo: notifies listening application of any certifications added by an identity's owner or neighborhood trustees\n\n        //!!! todo: notifies listening application of any key revocations or decertifications from owner or trustees\n    }\n\n    //! it unlistens from subscriptions no longer being used\n    set subscriptions(replacement: SubscriptionListenerMap) {\n        for (const [chan, sub] of Object.entries(this._subscriptions || {})) {\n            //!!! todo: match subscription filter settings\n            //XXXX if (! replacement.has(chan)) sub.events.removeAllListeners();\n        }\n        this._subscriptions = replacement;\n    }\n\n    get subscriptions() {\n        if (!this._subscriptions) return {}; // it creates an empty subscriptions object if not already set\n        return this._subscriptions;\n    }\n\n    private getChannelSub(\n        channel: string,\n        listener: DredMessageListener\n    ): ChannelSubscriptionListener {\n        const found = this.subscriptions[channel];\n        if (found) return found;\n        return this.mkChannelSub(channel, listener);\n    }\n\n    //! it creates new subscriptions and wires them up for notification to client application\n    //! it doesn't require client applications to guard for memory / event-listener leakage\n    mkChannelSub(channel: string, listener: DredMessageListener): ChannelSubscriptionListener {\n        const sub = new ChannelSubscriptionListener({\n            neighborhood: this.neighborhoodId,\n            channel,\n            listener,\n        });\n        return sub;\n    }\n\n    //!!! todo: extract fetch as a library function so any client and/or connectionManager\n    //      can avoiding reliance on any specific host from the neighborhood.\n    //     ... starts at least two requests from discovered servers; if a confirmation is not received\n    //     ... from neighborhood hosts within a short delay (~200ms),\n    //     ... it issues the same req to additional servers,\n    //     ... to get a decentralized confirmation of important functionalities\n    //    (see also todo zw3w737)\n\n    async fetch(path: string, { parse = true, debug = false, ...options }) {\n\n        //!! todo: it logs the pending request to an observable queue of\n        //    requests and keeps it updated with progress.\n        //!! todo: it exposes the progress info in a way that is easily consumed\n        //    by a React component.\n\n        if (path[0] !== \"/\") path = `/${path}`;\n\n        let host = (await this.discovery.getHostList())[0];\n        const proto = host.insecure ? \"http\" : \"https\";\n        const shortServer = `${host.address}:${host.port}`;\n        const url = `${proto}://${shortServer}${path}`;\n        // console.warn(`+fetch`, options.method, shortServer, path)\n\n        const result = await fetch(url, options);\n        if (debug) debugger;\n        if (result.ok) {\n            if (!parse) return result;\n\n            return result.json();\n        }\n        debugger\n        const err = await result\n            .json()\n            .catch(() => new Error(`${result.status} ${result.statusText} for ${path}`));\n        //!!! if one of the requests fails, it notifies the PeerConnectionManager\n        //     of the problem server\n\n        const { error, message, reason, recommendation, \"?developer?\": devMsg } = err;\n        const m = message || error;\n        this.events.emit(\"error\", {\n            reason: reason || err,\n            message: `host said: ${m}`,\n            recommendation: recommendation || \"try again or choose a different channel\",\n            [devMessage]:\n                devMsg || \"Developers should check whether the request is properly formed\",\n        });\n        throw new Error(error || message || reason)\n    }\n\n    async getNeighborhoods() {\n        const n = await this.discovery.getNeighborhoods();\n        return n;\n    }\n\n    async generateKey() {\n        if (this.identity) {\n            console.warn(`generateKey() already called; no-op duplicate call`);\n            return;\n        }\n        const key = (this.identity = await StringNacl.newKeyPair());\n        this.pubKeyString = encodeBase64(key.publicKey);\n        this.signer = new StringNacl(this.identity, this);\n    }\n\n    async signString(s: string): Promise<string> {\n        if (!this.identity || !this.signer)\n            throw new Error(`DredClient: can't sign() without a prior call to generateKey()`);\n\n        return this.signer.sign(s);\n    }\n\n    async verifySig(s: string, sigBase64: string, keyBase64: string): Promise<boolean> {\n        if (!this.signer) {\n            throw new Error(`DredClient: no signer; use generateKey() first`);\n        }\n\n        return this.signer.verifySig(s, sigBase64, keyBase64);\n    }\n\n    async createChannel(\n        channelName: string,\n        options: Partial<Omit<ChannelOptions, \"channelId\">> = {\n            encrypted: false,\n        }\n    ) {\n        //!!! todo: it delegates channel-creation to connection manager (see also todo zw3w737)\n\n        // this.log({ fetching: true, url });\n        const {\n            encrypted,\n            members = [],\n            allowJoining,\n            memberLimit,\n            expiresAt,\n            messageLifetime,\n        } = options || {};\n        if (encrypted) {\n            if (!this.identity || !this.signer) {\n                throw new Error(\n                    `createChannel: encrypted channel requires a prior call to generateKey()`\n                );\n            }\n            if (!allowJoining && !members.length) {\n                throw new Error(\n                    `createChannel (encrypted: true): must specify member list and/or allowJoining: true`\n                );\n            }\n            const signature = await this.signString(channelName);\n            options.owner = this.pubKeyString;\n            options.signature = signature;\n        }\n        const {\n            ... otherBodyAttrs\n        } = options;\n        const body = JSON.stringify(otherBodyAttrs);\n        try {\n            return await this.fetch(`/channel/${channelName}`, {\n                method: \"POST\",\n                body,\n                headers: {\n                    \"content-type\": \"application/json\",\n                    accept: \"application/json\",\n                },\n            });\n        } catch (err: any) {\n            let e: Error;\n            if (err instanceof Error) {\n                e = err;\n            } else {\n                console.warn(err.stack || err.message || JSON.stringify(err, null, 2));\n                e = new Error(err.error || err.message || err);\n            }\n            this.logger.error(\"createChannel at server failed:\", e.stack);\n            throw e;\n        }\n    }\n\n    async joinChannel(channelName: string) {\n        if (!this.pubKeyString) {\n            throw new Error(`joinChannel: requires a prior call to generateKey()`);\n        }\n        return this.addMemberToChannel(channelName, this.pubKeyString);\n    }\n\n    async addMemberToChannel(channelName: string, memberKeyBase64: string) {\n        if (!this.pubKeyString) {\n            throw new Error(`joinChannel: requires a prior call to generateKey()`);\n        }\n        try {\n            //!!! todo: it delegates member-adds to connection manager (see todo zw3w737)\n            return await this.fetch(`/channel/${channelName}/join`, {\n                method: \"POST\",\n                // debug: true,\n                headers: {\n                    \"content-type\": \"application/json\",\n                    accept: \"application/json\",\n                },\n                body: JSON.stringify({\n                    myId: this.pubKeyString,\n                    member: memberKeyBase64,\n                    signature: await this.signString(memberKeyBase64),\n                }),\n            });\n        } catch (err: any) {\n            this.logger.error(\"join-channel at server failed:\", err.message || err);\n            throw new Error(err.error || err);\n        }\n    }\n\n    //!!! todo: it uses the key-agreement protocol to encrypt channel messages\n    postEncrypted(channelName: string, plainMessage: EncryptedDredMessage, msgAttributes: Object) {}\n\n    //!!! todo: it delegates message-posting to connection manager.\n    //     see also todo zw3w737\n\n    //!!! todo zfnsmq8: it refuses to post plain-text messages into encrypted channels\n    //     see also todo y0w9cvr\n\n    async postMessage(channelName: string, oMsg: DredMessage) {\n        const sub = this.subscriptions[channelName];\n\n        const message = { ... oMsg };\n        this.logger.info(\"posting message \", message);\n        let { type, ocid, msg } = message;\n\n        if (\"string\" !== typeof msg) {\n            throw new Error(`message 'msg' attr must be a string, not a JSON object`);\n        }\n        if (!message.ocid) {\n            const _ocid = nanoid();\n            // console.log(\"(generated ocid)\");\n            ocid = message.ocid = _ocid;\n        }\n        // console.log({ ocid });\n        if (sub) {\n            sub.recentMsgs.add(ocid!);            \n        }\n\n        //! it guards usage for non-typescript users\n        if (!(type && msg)) {\n            debugger\n            throw new Error(`missing required 'type' and/or 'message'`);\n        }\n\n        const result = await this.fetch(`/channel/${channelName}/message`, {\n            method: \"POST\",\n            body: JSON.stringify(message),\n            headers: {\n                \"content-type\": \"application/json\",\n                accept: \"application/json\",\n            },\n        });\n        if (sub) {\n            sub.recentMsgs.delete(ocid!);\n            sub.recentMsgs.add(result.id);\n        }\n\n        result.ocid = ocid;\n        return result;\n    }\n\n    //! disconnects from neighborhood\n    disconnect() {\n        this.connManager.disconnect();\n    }\n}\n","import Redis from \"ioredis\";\n\ntype keyType = \"_abstract\" | string;\n\nexport class RedisSet {\n    redis: Redis;\n    key: keyType;\n    abstract: boolean;\n    constructor(redis: Redis, key: keyType = \"_abstract\") {\n        this.redis = redis;\n        this.key = key;\n        this.abstract = !!(key === \"_abstract\");\n    }\n    async has(key: string, setName?: string) {\n        if (this.abstract && !setName)\n            throw new Error(`abstract RedisSet requires setName in arg2`);\n        return this.redis.call(\"SISMEMBER\", setName || this.key, key);\n    }\n    async add(key: string, setName?: string) {\n        if (this.abstract && !setName)\n            throw new Error(`abstract RedisSet requires setName in arg2`);\n        return this.redis.call(\"SADD\", this.key, key);\n    }\n    async delete(key: string, setName?: string) {\n        if (this.abstract && !setName)\n            throw new Error(`abstract RedisSet requires setName in arg2`);\n        return this.redis.call(\"SREM\", this.key, key);\n    }\n}\n","import { Redis } from \"ioredis\";\n\ntype keyType = \"_abstract\" | string;\nexport interface ValueAdapter<V> {\n    toRedis: (v: V) => string;\n    fromRedis: (v: string) => V;\n}\nexport const StringValueAdapter: ValueAdapter<string> = {\n    toRedis(v: string) {\n        return v;\n    },\n    fromRedis(v: string) {\n        return v;\n    },\n};\nexport const JSONValueAdapter: ValueAdapter<object> = {\n    toRedis(v: object) {\n        return JSON.stringify(v);\n    },\n    fromRedis(v: string) {\n        return JSON.parse(v);\n    },\n};\nexport class RedisHash<KEYTYPE extends { toString(): string }, VALUETYPE = string> {\n    redis: Redis;\n    hashName: keyType;\n    abstract: boolean;\n    adapter: ValueAdapter<VALUETYPE>;\n    constructor(redis: Redis, hashName: string, adapter: ValueAdapter<VALUETYPE>) {\n        this.redis = redis;\n        this.hashName = hashName;\n        this.adapter = adapter;\n        this.abstract = !!(hashName === \"_abstract\");\n    }\n    async get(key: KEYTYPE, hashName?: string): Promise<VALUETYPE> {\n        if (this.abstract && !hashName)\n            throw new Error(`abstract RedisHash requires hashName in arg2`);\n\n        const hName = hashName || this.hashName;\n        const str = (await this.redis.call(\n            \"HGET\",\n            hName,\n            key.toString()\n        )) as string;\n        const parsed = this.adapter.fromRedis(str);\n        return parsed;\n    }\n\n    async has(key: KEYTYPE, hashName? : string) {\n        const hName = hashName || this.hashName;\n        const v = await this.get(key, hName)\n        return !!v\n    }\n\n    async keys(hashName?: string) {\n        if (this.abstract && !hashName)\n            throw new Error(`abstract RedisHash requires hashName in arg1`);\n\n            const hName = hashName || this.hashName;\n            return this.redis.call(\"HKEYS\", hName);\n    }\n\n    async set(key: KEYTYPE, value: VALUETYPE, hashName?: string) {\n        if (this.abstract && !hashName)\n            throw new Error(`abstract RedisHash requires hashName in arg3`);\n\n        const hName = hashName || this.hashName;\n        const v = this.adapter.toRedis(value);\n        return this.redis.call(\"HSET\", hName, key.toString(), v);\n    }\n\n    async delete(key: KEYTYPE, hashName?: string) {\n        if (this.abstract && !hashName)\n            throw new Error(`abstract RedisHash requires hashName in arg2`);\n\n        const hName = hashName || this.hashName;\n        return this.redis.call(\"HDEL\", hName, key.toString());\n    }\n}\n","// import { readFileSync } from \"fs\";\nimport util from \"tweetnacl-util\";\nconst { encodeUTF8, decodeUTF8, encodeBase64, decodeBase64 } = util;\n\nimport { DredHostDetails } from \"../types/DredHosts.js\";\nimport { Discovery, GenericDiscoveryOptions, promisedConnectionThresholds } from \"../types/Discovery.js\";\nimport { StringNacl } from \"../util/StringNacl.js\";\nimport { NbhId } from \"../types/ChannelSubscriptions.js\";\nimport { asyncDelay } from \"@poshplum/utils\";\n\n\nconst localNbh = \"localhost-nbh\";\ninterface DevDiscoveryOptions extends GenericDiscoveryOptions {\n    hosts?: DredHostDetails[], \n}\n\nexport class StaticHostDiscovery extends Discovery {\n    hosts: DredHostDetails[];\n    async getNeighborhoods() {\n        await asyncDelay(1);\n        return [ localNbh ];\n    }\n\n    // getPubKeyFromFs(port:number): string { //Uint8Array\n    //     const pubKeyFile = `config/keys/server.port-${port}.pub`;\n    //     const privateKeyFile = `config/keys/server.port-${port}.sec`;\n    //     try {\n    //         const pubKey = readFileSync(pubKeyFile);\n    //         const key64 = pubKey.toString().trim();\n    //         console.log(`server ${port} pubkey:`, key64);\n    //         return key64;\n    //         // return decodeBase64(key64)\n    //     } catch (e) {\n    //         console.error(`No pubkey found for server  in`, pubKeyFile);\n\n    //         StringNacl.newKeyPair().then(key => {\n    //             console.log(\"\\nTo create a new key for this local dev server:\\n\",\n    //                 `add '${encodeBase64(key.publicKey)}' to ${pubKeyFile}\\n`,\n    //                 `add '${encodeBase64(key.secretKey)}' to ${privateKeyFile}\\n`,\n    //             );\n    //             throw new Error(`missing required local key configuration for local dev server`)\n    //         })\n    //         return \"no pubkey\"\n    //     }\n    // }\n    static defaultHosts() : DredHostDetails[] {\n        return [{\n            serverId: \"singleton\",\n            address: \"127.0.0.1\",\n            port: 3029,\n            insecure: true,            \n            // publicKey: this.getPubKeyFromFs(3029),\n        }]\n    }\n    setupDefaultHosts() {\n        return this.reset((this.constructor as typeof StaticHostDiscovery).defaultHosts());\n    }\n    constructor(options : DevDiscoveryOptions) {\n    const {\n        neighborhood, hosts\n    } = options;\n        if (neighborhood) throw new Error(`DevEnvLocalDiscovery always uses `+localNbh)\n        super({ neighborhood: localNbh });\n        this.hosts = hosts || (StaticHostDiscovery.defaultHosts())\n    }\n    async initHostDiscovery() {\n        this.setupDefaultHosts();\n    }\n\n    toJSON() {\n        return { localDevHosts: this.hosts };\n    }\n    async getHostList() {\n        if (!this.hosts) throw new Error(`call setupDefaultHosts()`);\n        await asyncDelay(1);\n        return this.hosts;\n    }\n    async getConnectionThresholds() : promisedConnectionThresholds {\n        if (!this.hosts) { throw new Error(`no this.hosts`) }\n\n        if (this.hosts.length > 2) {\n            return {minimal:2, healthy: 3}\n        }\n        if (this.hosts.length > 1) {\n            return {minimal:1, healthy: 2}\n        }\n        return {minimal: 1, healthy: 1}\n    }\n}\n","//@ts-check\n\nimport { colors } from \"../picocolors/picocolors.js\";\nconst {\n    bgBlackBright,\n    blue,\n    blueBright,\n    green,\n    greenBright,\n    red,\n    redBright,\n    yellow,\n    yellowBright,\n    isColorSupported,\n    bgBlack,\n    bgBlueBright,\n    bold,\n    black,\n} = colors;\n\nimport { Redis, RedisOptions } from \"ioredis\";\nimport { get, Server } from \"http\";\nimport express from \"express\";\nimport type { Application } from \"express\";\nimport bodyParser from \"body-parser\";\nimport cors from \"cors\";\nimport compression from \"compression\";\n\n//@ts-ignore\nimport { RedisChannels } from \"../redis/streams\";\n\nimport { DredClient, DredClientArgs } from \"../client/DredClient.js\";\nimport { RedisSet } from \"../redis/RedisSet.js\";\nimport { Subscriber } from \"../Subscriber.js\";\nimport {\n    JSONValueAdapter,\n    RedisHash,\n    StringValueAdapter,\n    ValueAdapter,\n} from \"../redis/RedisHash.js\";\nimport { ChannelOptions } from \"../types/ChannelOptions.js\";\nimport { StringNacl } from \"../util/StringNacl.js\";\nimport { Discovery } from \"../types/Discovery.js\";\nimport { DredHostDetails } from \"../types/DredHosts.js\";\nimport {\n    ChanId,\n    SubscriptionList,\n    NbhId,\n    ChannelSubOptions,\n} from \"../types/ChannelSubscriptions.js\";\nimport { autobind } from \"@poshplum/utils\";\nimport { StaticHostDiscovery } from \"../peers/StaticHostDiscovery.js\";\nimport { zonedLogger } from \"@poshplum/utils\";\n\nconst logging = parseInt(process.env.LOGGING || \"0\");\nexport interface ExpressWithRedis extends express.Application {\n    redis: null | typeof Redis;\n}\n\ntype ListenerSubscriptionList = ChannelSubscriber[];\n\nexport type ChannelSubscriber = {\n    channel: ChanId;\n    stream: streamHandle;\n};\ntype changeFeedUpdater = (...messages: rStreamMsg[]) => void;\ntype consumerErrorNotifier = (channel: ChanId, e: Error) => void;\ntype rChannelError = {\n    channel: string;\n    type: \"error\";\n    message: string;\n    reason: string;\n};\n\ntype rHeartbeatMessage = {\n    type: \"heartbeat\" | \"heartbeat-info\";\n    timerInterval?: number;\n};\n\ntype rStreamMsg =\n    | rHeartbeatMessage\n    | rChannelError\n    | {\n          //(rMsgRaw | rMsgParsed) &\n          id: string;\n          channel: ChanId;\n          type: string;\n          data: string;\n          [key: string]: string | undefined;\n      };\n\ntype streamHandle = {\n    team: any; //!!! todo: enhance these types\n    consumer: any;\n};\n\nconst peers = new Set<DredClient>();\n\nconst optionsSerializer: ValueAdapter<ChannelOptions> = {\n    toRedis(v: ChannelOptions) {\n        if (\"member\" !== v.approveJoins && \"open\" !== v.approveJoins) v.approveJoins = \"owner\";\n\n        return JSONValueAdapter.toRedis(v);\n    },\n    fromRedis(v: string) {\n        const g = JSONValueAdapter.fromRedis(v) as any;\n        const opts = { ...g } as ChannelOptions;\n        opts.createdAt = new Date(g.createdAt);\n        g.expiresAt && (opts.expiresAt = new Date(g.expiresAt));\n        return opts;\n    },\n};\n\ntype DredServerArgs = DredClientArgs & {\n    api?: express.Application;\n    serverDb?: number;\n};\n\n//!!! todo: augment to support a list of nbh's, with req details for nbh selection\n//    - start by using nbh prefix in redis keys.\n\nlet clientIndex = 1;\n\nexport class DredServer {\n    api: express.Application;\n    discovery: Discovery;\n    redisUrl: string;\n    redisDb: number;\n    redis?: Redis;\n    channelConn: RedisChannels;\n    listener: null | Server; // http.Server from node types\n    args: DredServerArgs;\n    channelList!: RedisHash<string, string>;\n    channelOptions!: RedisHash<string, ChannelOptions>;\n    producers: Map<string, any>;\n    subscribers: Map<string, Set<Subscriber>>;\n    clientArgs: DredServerArgs;\n    verifier: StringNacl;\n    serverId: string;\n    myServerInfo?: DredHostDetails;\n    logger: ReturnType<typeof zonedLogger>;\n\n    resetting = false;\n    get nbh() {\n        return this.args.neighborhood;\n    }\n\n    setupExpressHandlers() {\n        this.api.use(compression());\n        this.api.use((req, res, next) => {\n            res.locals.startTime = new Date().getTime();\n\n            this.log(`-> ${req.method} ${req.originalUrl}`);\n            next();\n        });\n\n        //!!! todo: 61pk3h0 it applies a more explicit Access-Control-Allow-Origin policy,\n        //    ... checking credentials and/or domain name as part of its CORS check,\n        //    ... according to its configuration & setup\n\n        this.api.use(cors<Request>());\n\n        this.api.use(bodyParser.json({ limit: \"1mb\" }));\n\n        //! it allows handlers to be mocked\n        this.api.post(\"/channel/:channelId\", (...args) => {\n            this.createChannel(...args);\n        });\n        this.api.post(\"/channel/:channelId/join\", (...args) => {\n            this.joinInChannel(...args);\n        });\n        this.api.post(\"/channel/:channelId/message\", (...args) => {\n            this.postMessageInChannel(...args);\n        });\n        this.api.get(\"/channels\", (...args) => {\n            this.getChannels(...args);\n        });\n        this.api.get(\"/channels/subscribe\", (...args) => {\n            //! it allows clients to subscribe to many channels and receive notification about updates in any of them\n            // this.subscribeToChannel(...args);\n        });\n\n        this.api.options(\"/channels/listen\", (...args) => {\n            //! it approves any allowed CORS / cross-origin requests.  These can be limited by domain name\n            //  or other attributes of the cross-origin OPTIONS request.\n        });\n        this.api.post(\"/channels/listen\", (...args) => {\n            //! it allows clients to subscribe to many channels and receive notification about updates in any of them\n            this.listenOnChannels(...args);\n        });\n        this.api.use(this.resultLogger);\n    }\n\n    constructor(args: DredServerArgs, serverId: string, redisDb: number) {\n        this.args = args;\n        debugger;\n        const loggerName = `dred${serverId}`;\n        this.logger = zonedLogger(loggerName, {\n            serverId,\n            levels: {\n                [loggerName]: logging ? \"info\" : \"warn\",\n                _message: `(env LOGGING=${logging})`,\n            },\n        });\n\n        this.serverId = serverId;\n        this.discovery = DredClient.resolveDiscovery(args);\n        // const t= express()\n        this.log(`+server '${serverId}'`, this.discovery, null, 2);\n        this.api = this.createExpressServer();\n        // const t= express();\n\n        const redisUrl = (this.redisUrl = process.env.REDIS_URL || \"redis://localhost:6379\");\n\n        this.listener = null;\n        this.verifier = new StringNacl(undefined, this);\n        this.producers = new Map();\n        this.subscribers = new Map();\n        this.redisDb = redisDb || 0;\n        this.setupRedis(redisUrl);\n        // setup message replication for the redis instance\n        this.setupReplication();\n        // this.channelConn._log.error = console.error.bind(console);\n        this.clientArgs = args;\n\n        this.setupExpressHandlers();\n    }\n\n    setupRedis(url: string | undefined) {\n        if (this.redis) throw new Error(`redis connection is already set up`);\n        // redis.subscribe(...).on(\"message\", (event) => {\n        //     for (const peer of peers) {\n        //         peer.addEvent(event)\n        //     }\n        // })\n\n        //!!! todo: use configured Redis connection details\n        this.log(`Setting up Redis connection: ${url || \"default\"}, db: ${this.redisDb}`);\n        // console.log(`REDIS_URL ${url}`);\n        const options: RedisOptions = {\n            db: this.redisDb,\n\n            // keyPrefix: `${this.nbh}::`  //!!! todo vet this technique.\n        };\n        if (url) {\n            this.redis = new Redis(url, options);\n        } else {\n            this.redis = new Redis(options);\n        }\n\n        this.channelList = new RedisHash<string, string>(\n            this.redis,\n            \"channels\",\n            StringValueAdapter\n        );\n        this.channelOptions = new RedisHash(this.redis, \"channelOptions\", optionsSerializer);\n\n        //!!! todo: allows the application name to override 'dred' setting in channel names created in Redis\n        this.channelConn = new RedisChannels({\n            application: `${this.nbh}::`,\n            redis: {\n                url: url,\n                db: this.redisDb,\n            },\n        });\n        this.channelConn._log = this.logger;\n        this.ensureDefaultChannels();\n    }\n\n    //! it has a mockable function for starting the express server\n    createExpressServer(): express.Application {\n        return this.args.api || express();\n    }\n\n    async pendingSetup() {\n        return this.setupPending;\n    }\n    private setupPending?: Promise<any>;\n    //!!! todo: once for each nbh\n    ensureDefaultChannels() {\n        if (this.setupPending) return this.setupPending;\n\n        return (this.setupPending = new Promise(async (res) => {\n            await this.doChannelSetup(\"_chans\");\n            await this.doChannelSetup(\"_auth\");\n            await this.doChannelSetup(\"news\");\n            await this.doChannelSetup(\"discussion\");\n            this.setupPending = undefined;\n            res(true);\n        }));\n    }\n\n    async doChannelSetup(channel: ChanId, options: Partial<ChannelOptions> = {}) {\n        // debugger\n        const chan = await this.channelList.has(channel);\n        if (!chan) {\n            await this.channelList.set(channel, \"1\");\n        }\n        const streams = this.channelConn;\n        if (!streams) {\n            if (this.resetting) {\n                this.logger.warn(\"ignoring continuing channel setup for %s while racing with a subsequent reset!\")\n                return \n            } else {\n                this.logger.error(\n                    \"??? how can this happen?? streams undefined, can't use(%s) for producing\",\n                    channel\n                );\n                throw new Error(`streams undefined, can't use(${channel}) for producing`);\n            }\n        }\n        const stream = await streams.use(channel);\n\n        //!!! revisit this with a more specific plan : )\n        await streams.produce(stream, \"first event in this channel\", { type: \"channel:genesis\" });\n        const o = { channelId: channel, ...options };\n        this.channelCreated(channel, o);\n    }\n\n    //\n    async listen() {\n        await this.setupPending;\n\n        const myInfo = (this.myServerInfo =\n            this.myServerInfo || (await this.discovery.myServerInfo(this.serverId)));\n        if (!myInfo) throw new Error(`can't identify my own info`);\n        const { port, address } = myInfo;\n        this.listener = this.api.listen(port, address);\n        this.log(`server '${this.serverId}' listening at ${address}:${port}`);\n        return this.listener;\n        // express\n        //       listen(port: number, hostname: string, backlog: number, callback?: () => void): http.Server;\n        //       listen(port: number, hostname: string, callback?: () => void): http.Server;\n    }\n\n    async reset(reconnect?: boolean, finalCleanup?: (r?: Redis) => any) {\n        await this.channelConn.cleanup().catch(warning.bind(this, \"channelConn.cleanup()\"));\n        // await this.channelConn.this?.redis?.quit().catch(warning.bind(this,\"channelConn.redis.quit()\"));\n        // this.channelConn?.redis?.disconnect();\n        finalCleanup?.(this.redis);\n        this.resetting = true;\n        await this.redis?.quit().catch(warning.bind(this, \"redis.quit()\"));\n        this.redis?.removeAllListeners();\n        this.channelConn = undefined;\n        this.redis = undefined;\n\n        const doReconnect = reconnect ?? true;\n        if (doReconnect) {\n            this.setupRedis(this.redisUrl);\n            this.resetting = false;                \n            return this.setupPending\n        }\n        function warning(this: DredServer, activityName) {\n            return (e) => {\n                this.warn(`during close: error in ${activityName}:\\n\\t`, e.message || e);\n            };\n        }\n    }\n\n    async close() {\n        this.cancelSubscribers();\n        this.reset(false);\n        this.listener?.close();\n    }\n    async listenDetails() {}\n\n    get address() {\n        const { listener } = this;\n        if (!listener) throw new Error(`not yet listening`);\n\n        const addr = listener.address();\n        throw new Error(`is this needed?`);\n\n        if (addr === null) throw new Error(`server is not listening`);\n        if (\"string\" === typeof addr) throw new Error(`Unix socket not supported currently`);\n\n        return addr;\n    }\n\n    mkClient(serverSelection: string, clientArgs: Partial<DredClientArgs> = {}): DredClient {\n        const discovery: Discovery = clientArgs.discovery ?? this.clientArgs.discovery;\n        if (!discovery) throw new Error(\"discovery is required\");\n        const oneHost = discovery.hosts!.find((h) => h.serverId === serverSelection);\n        if (!oneHost) {\n            this.logger.error(`server ${serverSelection} not found in discovery`, discovery);\n            throw new Error(`server ${serverSelection} not found in discovery`);\n        }\n        const singleDiscovery = new StaticHostDiscovery({\n            hosts: [oneHost],\n        });\n\n        return new DredClient({\n            name: `${serverSelection || \"\"}-${clientIndex++}`,\n            ...this.clientArgs,\n            ...clientArgs,\n            discovery: singleDiscovery,\n        });\n    }\n\n    log(a1: string, ...args: any[]) {\n        this.logger.info(a1, ...args);\n        // logging && console.log(...args);\n    }\n    warn(a1: string, ...args: any[]) {\n        this.logger.warn(a1, ...args);\n        // logging && console.warn(...args);\n    }\n\n    resultLogger: express.RequestHandler = (req, res, next) => {\n        const now = new Date().getTime();\n        const elapsed = now - res.locals.startTime;\n\n        this.log(`<- ${res.statusCode} ${req.method} ${req.originalUrl || req.url} ${elapsed}ms`);\n    };\n    getChannels: express.RequestHandler = async (req, res, next) => {\n        const found: string[] = (await this.channelList.keys()) as string[];\n        const channels = found.filter((x) => x[0] !== \"_\");\n        res.status(200).json({ channels });\n    };\n    createChannel: express.RequestHandler = async (req, res, next) => {\n        const { channelId } = req.params;\n        const options: ChannelOptions = req.body;\n        const found = await this.channelList.has(channelId);\n        if (found) {\n            this.warn(`Channel creation failed: ${channelId} already exists`);\n            res.status(400).json({ error: \"channel already exists\" });\n            return next();\n        }\n\n        let {\n            channelId: invalidChanId,\n            encrypted,\n            owner,\n            members = [],\n            requests = [],\n            allowJoining,\n            approveJoins,\n            memberLimit,\n            expiresAt,\n            messageLifetime,\n            signature,\n        } = options;\n\n        if (invalidChanId) {\n            res.status(422).json({\n                error: \"body.channelId is invalid; use params.channelId instead.\",\n            });\n            return next();\n        }\n\n        expiresAt = expiresAt ? new Date(expiresAt) : undefined;\n        const now = new Date();\n        if (expiresAt && now > expiresAt) {\n            res.status(422).json({\n                error: \"channel expiresAt is already in the past\",\n            });\n            return next();\n        }\n\n        // this.log(\"chan create\");\n        if (encrypted) {\n            if (!owner) {\n                res.status(400).json({\n                    error: \"missing required 'owner' setting for an encrypted channel\",\n                });\n                return next();\n            }\n            if (!signature) {\n                res.status(400).json({\n                    error: \"missing signature; use the result of sign(channelName)\",\n                });\n                return next();\n            }\n            const verified = await this.verifier.verifySig(channelId, signature, owner);\n            if (!verified) {\n                res.status(400).json({\n                    error: \"bad signature; use the result of sign(channelName)\",\n                });\n                return next();\n            }\n        }\n        //! it doesn't allow any extraneous JSON keys to leak through the options during channel-creation\n        //   note: have a use-case for storing more details with the channel options?  Let's discuss.\n        const opts: ChannelOptions = {\n            channelId,\n            encrypted,\n            owner,\n            members,\n            requests,\n            allowJoining,\n            approveJoins,\n            memberLimit,\n            expiresAt,\n            messageLifetime,\n            signature,\n            createdAt: new Date(),\n        };\n\n        await this.setChanOptions(channelId, opts);\n        await this.channelList.set(channelId, \"1\");\n        await this.channelCreated(channelId, opts);\n        res.json({\n            id: channelId,\n            status: \"created\",\n            ...opts,\n        });\n        next();\n    };\n\n    async channelCreated(channel, options: ChannelOptions) {\n        //! it allows specific subclass of dred server to be notified of channel-creation\n        const streams = this.channelConn;\n        const chans = await streams.use(\"_chans\");\n\n        this.log(\"channelCreated\", channel, options);\n        //! it emits a channel-created event in the _chans meta-channel.\n        //   applications with interest in such things can subscribe to that\n        //   channel to get the news\n        await streams.produce(chans, \"a channel was created\", {\n            type: \"chanCreated\",\n            channel,\n            options: JSON.stringify(options),\n        });\n    }\n\n    async getChanOptions(channelName: string): Promise<ChannelOptions> {\n        const obj = await this.channelOptions.get(channelName);\n        return obj as ChannelOptions;\n    }\n    async setChanOptions(channelName: string, options: ChannelOptions): Promise<void> {\n        await this.channelOptions.set(channelName, options);\n    }\n\n    joinInChannel: express.RequestHandler = async (req, res, next) => {\n        const { channelId } = req.params;\n        const { myId, member, signature } = req.body;\n        const found = await this.channelList.has(channelId);\n\n        const now = new Date();\n\n        if (!found) {\n            this.warn(`Join failed: Channel ${channelId} not found`);\n            res.status(400).json({ error: \"invalid channel\" });\n            return next();\n        }\n        //! the channel must be encrypted (non-encrypted channels are open by definition)\n        const opts = await this.getChanOptions(channelId);\n\n        //! trying to join an expired channel produces an error\n        if (opts.expiresAt && now > opts.expiresAt) {\n            this.warn(`Join failed: Channel ${channelId} is expired`);\n            this.log(\n                `expiration '${opts.expiresAt.getTime() % 100000}, now '${now.getTime() % 100000}`\n            );\n            res.status(422).json({\n                error: \"this channel's expiresAt is already past\",\n            });\n            return next();\n        }\n\n        if (!opts.encrypted) {\n            res.status(400).json({\n                error: \"/channel/:id/join is not needed for non-encrypted channels\",\n            });\n            return next();\n        }\n        if (!signature) {\n            res.status(400).json({\n                error: \"missing required 'signature' field in body\",\n            });\n            return next();\n        }\n        opts.members = opts.members || [];\n        opts.requests = opts.requests || [];\n\n        //! non-owners cannot exceed the memberLimit (if configured)\n        let overMemberLimit = opts.memberLimit && opts.members.length >= opts.memberLimit;\n\n        let requestOnly = false;\n        let approvedVerifier;\n        if (opts.owner == myId) {\n            //! the owner can join someone by pubKey, even if the memberLimit is reached\n            overMemberLimit = false;\n            approvedVerifier = myId;\n\n            this.log(\"owner-approved join\");\n        } else if (\"member\" == opts.approveJoins && (opts.members || []).includes(myId)) {\n            //! a member can join someone by pubKey if approveJoins: member\n            this.log(\"member-approved join\");\n            approvedVerifier = myId;\n        } else if (opts.allowJoining) {\n            //! a non-member can join themself if allowJoining is true and approveJoins is \"open\"\n            if (member !== myId) {\n                res.status(400).json({\n                    error: \"can't invite others\",\n                });\n                return next();\n            }\n\n            //! non-member joins are requests unless approveJoins = \"open\"\n            if (\"open\" !== opts.approveJoins) {\n                requestOnly = true;\n                opts.requests.push(myId);\n                approvedVerifier = myId;\n                //!!! todo: join requests, when not open, are simple messages in the channel,\n                //!    which clients can read, prompting members or owner to issue an approval.\n            } else {\n                this.log(\"self-join\");\n                approvedVerifier = myId;\n            }\n        }\n        if (!approvedVerifier && !requestOnly) {\n            this.warn(\"unauthorized\");\n\n            res.status(403).json({\n                error: \"unauthorized\",\n            });\n            return next();\n        }\n\n        if (opts.members.includes(member)) overMemberLimit = false;\n        if (overMemberLimit) {\n            this.warn(`Join failed: Channel ${channelId} is full`);\n\n            res.status(403).json({\n                error: \"channel is full\",\n            });\n            return next();\n        }\n\n        let verified, error;\n        try {\n            verified = await this.verifier.verifySig(member, signature, approvedVerifier);\n            if (!verified) error = \"verify failed\";\n        } catch (e: any) {\n            error = e.message;\n        }\n        if (!verified) {\n            this.warn(`Join failed: Signature verification failed - ${error}`);\n            res.status(400).json({\n                error: `bad signature: ${error}`,\n            });\n            return next();\n        }\n\n        if (requestOnly) {\n            opts.requests.push(myId);\n        } else {\n            opts.members.push(member);\n        }\n        await this.setChanOptions(channelId, opts);\n\n        //! if allowed, it returns a success indicator\n        res.json({\n            status: \"joined\",\n        });\n        next();\n    };\n\n    async mkChannelProducer(channelId: any) {\n        return this.channelConn.use(channelId);\n    }\n\n    postMessageInChannel: express.RequestHandler = async (req, res, next) => {\n        const { channelId } = req.params;\n        this.log(\"postMessageInChannel\", channelId);\n        const found = await this.channelList.has(channelId);\n        if (!found) {\n            res.status(404).json({\n                error: \"channel not found\",\n            });\n            return next();\n        }\n        const message = req.body;\n\n        //!!! todo y0w9cvr: it refuses to post plain-text messages into encrypted channels\n        //     see also todo zfnsmq8\n\n        // Add source server identification to avoid circular replication\n        message.sourceServer = this.serverId;\n        \n        this.log(\"server: postMessage\", message);\n        const tunnelProducer = await this.mkChannelProducer(channelId);\n        const { msg, _type, _data, ...moreDetails } = message;\n\n        //! it extracts and SILENTLY ignores reserved keys _type, _data in client-provided event details.\n        // if (_type) console.warn(\"ignoring reserved key '_type' in client-provided message\");\n        // if (_data) console.warn(\"ignoring reserved key '_data' in client-provided message\");\n\n        if (\"string\" !== typeof msg) {\n            res.status(422).json({\n                error: \"message must be a string, not a JSON object\",\n            });\n            return next();\n        }\n        if (!msg) {\n            res.status(422).json({\n                error: \"missing required 'msg' attribute for posting message in channel\",\n            });\n        } else if (!moreDetails.ocid) {\n            res.status(422).json({\n                error: \"missing required 'ocid' attribute for posting message in channel\",\n            });\n        } else if (!moreDetails.type) {\n            res.status(422).json({\n                error: \"missing required 'type' attribute for posting message in channel\",\n            });\n        } else {\n            const id = await this.channelConn.produce(tunnelProducer, msg, moreDetails);\n            res.json({ id, status: \"created\" });\n        }\n        next();\n    };\n\n    cancelSubscribers() {\n        let count = 0;\n        for (const [chan, subscribers] of this.subscribers) {\n            for (const sub of subscribers) {\n                sub.cancel();\n                count++;\n            }\n        }\n        this.warn(`Cancelled ${count} channel subscribers`);\n    }\n\n    get subscribeTimeout() {\n        return 10000;\n    }\n\n    listenOnChannels: express.RequestHandler = async (req, res, next) => {\n        let cancelled = false;\n        const subscriptions: SubscriptionList = req.body;\n        res.contentType(\"application/ndjson\");\n        res.useChunkedEncodingByDefault = false;\n        // res.setHeader(\"x-hi\", \"there\");\n        this.log(\"listening for\", subscriptions);\n        //!!! todo: it validates authorization as appropriate for each requested channel\n\n        const sendUpdate: changeFeedUpdater = (...messages) => {\n            // if (json.event !== \"keepalive\") debugger\n            for (const json of messages) {\n                const update = JSON.stringify(json);\n                res.write(update + \"\\n\");\n                // debug(\"update: \", update)\n            }\n            (res as any).flush(); //! flushes writes through compression middleware\n        };\n        const myStreamListeners: ListenerSubscriptionList = [];\n        const timerInterval = 7000;\n        //! it sends heartbeat signals every so often to clients\n        //!!! todo: heartbeat interval can be configured\n        const timer = setInterval(() => {\n            this.log(\"server: client <- heartbeat\");\n            sendUpdate({ type: \"heartbeat\" });\n        }, timerInterval);\n        timer.unref(); //! the heartbeat-timer never blocks the process from exiting when it's otherwise done\n\n        //! it tells clients how frequently they should expect a heartbeat\n        sendUpdate({ type: \"heartbeat-info\", timerInterval });\n\n        const cleanup = () => {\n            //! it cleans up all the internal subscriptions\n            for (const mySub of myStreamListeners) {\n                const { channel, stream } = mySub;\n                this.channelConn.unsubscribe(stream);\n            }\n            clearInterval(timer);\n        };\n        res.on(\"close\", cleanup);\n\n        const cancel = () => {\n            cancelled = true;\n            res.end();\n            cleanup();\n            next();\n        };\n\n        const notifyConsumeError: consumerErrorNotifier = (channel, consumeError) => {\n            if (!cancelled) {\n                sendUpdate({\n                    channel,\n                    type: \"error\",\n                    message: \"internal stream consumer failed\",\n                    reason: consumeError.message,\n                });\n                this.logger.error(`${channel} consume error; TODO: reconnect/retry`, consumeError);\n                cleanup();\n                next();\n            }\n        };\n\n        let anySuccesses = 0;\n        let warnings: any[] = [];\n        for (const sub of subscriptions) {\n            const { channel } = sub;\n            const found = await this.channelList.has(channel);\n            if (!found) {\n                //! sends a warning note but does not fail unless there are no valid subscriptions\n                warnings.push({\n                    //!!! todo: review & craft the shape of this for consistency with other warnings that may be necessary to send to clients\n                    channel,\n                    type: \"warning\",\n                    message: \"invalid or expired channel\",\n                });\n            }\n\n            const subscriber = await this.listenOneChannel(sub, sendUpdate, notifyConsumeError);\n            myStreamListeners.push({ channel, stream: subscriber });\n            if (subscriber) anySuccesses += 1;\n        }\n        if (!anySuccesses) {\n            res.status(404).json({ error: \"no valid subscriptions in request\" });\n            return cancel();\n        } else if (warnings.length) {\n            sendUpdate.apply(this, warnings);\n        }\n    };\n\n    async listenToNeighborhood() {\n        //!!! todo: it connects with a DredClient for each neighborhood host\n        //!!! todo: it subscribes to all channels in the neighborhood\n        //   ...and replicates messages seen in those channels,\n        //   ... along with our own confirmation of the events\n        //!!! todo: it keeps a recency list of messages seen from other servers,\n        //     and replicates confirmations instead of full messages in that case.\n    }\n\n    async listenOneChannel(\n        sub: ChannelSubOptions,\n        sendUpdate: changeFeedUpdater,\n        notifyConsumerError: consumerErrorNotifier\n    ) {\n        //! it leverages the redis-streams module's cache of per-channel connections\n        const channelStream = await this.channelConn.use(sub.channel);\n        await this.channelConn.subscribe(channelStream);\n\n        //! it spawns asynchronous monitoring in each channel\n        this.monitorChannelChanges(channelStream, sub, sendUpdate, notifyConsumerError);\n        return channelStream;\n    }\n\n    private async monitorChannelChanges(\n        channelStream: streamHandle,\n        sub: ChannelSubOptions,\n        sendUpdate: changeFeedUpdater,\n        notifyConsumerError: consumerErrorNotifier\n    ) {\n        try {\n            for await (const events of this.channelConn.consume(\n                channelStream,\n                \"all\",\n                10,\n                this.subscribeTimeout\n            )) {\n                for (const e of events) {\n                    const { id: mid, ocid, type, data, ...meta } = e;\n                    this.log(\n                        bgBlueBright(black(bold(`    <- ocid ${ocid} in ${sub.channel}: `))),\n                        e.data.length,\n                        \"bytes\"\n                    );\n                    debugger;\n                    // const parsed = JSON.parse(data);\n                    //!!! todo: apply filters from the subscription\n                    sendUpdate({\n                        mid,\n                        channel: sub.channel,\n                        type,\n                        nbh: this.nbh,\n                        msg: data,\n                        ocid,\n                        ...meta,\n                    });\n                }\n            }\n        } catch (consumeError) {\n            notifyConsumerError(sub.channel, consumeError as Error);\n        }\n    }\n\n    setupReplication() {\n        if (!this.redis) {\n            this.warn(\"Cannot setup replication: Redis not initialized\");\n            return;\n        }\n\n        this.log(`Setting up message replication for server ${this.serverId}`);\n        \n        // Get all other servers from discovery to create client connections\n        this.discovery.getHostList().then(hosts => {\n            // Filter out myself\n            const otherHosts = hosts.filter(host => host.serverId !== this.serverId);\n            \n            if (otherHosts.length === 0) {\n                this.log(`No other hosts found for replication`);\n                return;\n            }\n\n            this.log(`Found ${otherHosts.length} other hosts for replication`);\n            \n            // Create a client connection to each other server\n            for (const host of otherHosts) {\n                try {\n                    const peerClient = this.mkClient(host.serverId);\n                    \n                    // Listen for all channel creations and messages by subscribing to all channels\n                    peerClient.subscribeToChannels({\n                        '*': async (message) => {\n                            try {\n                                // Skip if this was originally our message to prevent circular replication\n                                if (message.sourceServer === this.serverId) {\n                                    this.log(`Replication: skipping our own message from ${host.serverId}`);\n                                    return;\n                                }\n                                \n                                this.log(`Replication: received message on channel ${message.channel || '*'} from peer ${host.serverId}`);\n                                \n                                // Check if this is a channel creation message\n                                if (message.type === \"channel:genesis\") {\n                                    const channel = message.channel;\n                                    this.log(`Replication: channel ${channel} created on peer ${host.serverId}`);\n                                    // Ensure channel exists locally\n                                    try {\n                                        const exists = await this.channelList.has(channel);\n                                        if (!exists) {\n                                            await this.channelList.set(channel, \"1\");\n                                            this.log(`Replication: created local channel ${channel} from peer ${host.serverId}`);\n                                        }\n                                    } catch (err) {\n                                        this.warn(`Replication: Failed to create local channel ${channel}: ${err}`);\n                                    }\n                                } else if (message.msg) {\n                                    // For regular messages with content\n                                    try {\n                                        // Get producer for the channel\n                                        const targetChannel = message.channel || '*';\n                                        const producer = await this.mkChannelProducer(targetChannel);\n                                        \n                                        // Extract message content and metadata\n                                        const { msg, type, ocid, sourceServer, ...otherDetails } = message;\n                                        \n                                        // Ensure sourceServer is preserved to prevent circular replication\n                                        const messageDetails = {\n                                            type: type || 'replicated',\n                                            ocid: ocid || `repl-${Date.now()}`,\n                                            sourceServer: sourceServer || host.serverId,\n                                            ...otherDetails\n                                        };\n                                        \n                                        // Use the correct channelConn.produce method to add the message to the local channel\n                                        await this.channelConn.produce(producer, msg, messageDetails);\n                                        this.log(`Replication: replicated message to channel ${targetChannel}`);\n                                    } catch (err) {\n                                        this.warn(`Replication: Failed to replicate message to channel ${message.channel || '*'}: ${err}`);\n                                    }\n                                }\n                            } catch (err) {\n                                this.warn(`Replication: Error processing message from ${host.serverId}: ${err}`);\n                            }\n                        }\n                    });\n                    \n                    this.log(`Replication: setup for peer server ${host.serverId} complete`);\n                } catch (err) {\n                    this.warn(`Replication: Failed to set up connection to peer ${host.serverId}: ${err}`);\n                }\n            }\n        }).catch(err => {\n            this.warn(`Failed to get host list for replication: ${err}`);\n        });\n    }\n}\n\nexport async function createServer(options: DredServerArgs, serverId: string, serverDb: number) {\n    const server = new DredServer(options, serverId, serverDb);\n    const { api, redis } = server;\n    api.set(\"redis\", redis);\n\n    api.use(express.json({}));\n    const messagesInChannel = new RedisSet(redis);\n\n    return server;\n}\n"],"names":["uuidv4","name","ReadableStream","platformReadableStream","__publicField","__decorateClass","fetch","encodeUTF8","decodeUTF8","encodeBase64","decodeBase64","sign","logging","EventEmitter","asyncDelay","Redis"],"mappings":"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"}